diff --git a/.gitignore b/.gitignore
new file mode 100644
index 00000000..28d589ba
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,27 @@
+dist
+dist-*
+cabal-dev
+*.o
+*.hi
+*.chi
+*.chs.h
+*.dyn_o
+*.dyn_hi
+.hpc
+.hsenv
+.cabal-sandbox/
+cabal.sandbox.config
+*.prof
+*.aux
+*.hp
+*.eventlog
+.stack-work/
+cabal.project.local
+cabal.project.local~
+.HTF/
+.ghc.environment.*
+stack.yaml
+*.swm
+*.swo
+*.swp
+test_results/**
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 00000000..f3ae7934
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,161 @@
+# This Travis job script has been generated by a script via
+#
+#   haskell-ci '--output=.travis.yml' '--config=cabal.haskell-ci' 'cabal.project'
+#
+# For more information, see https://github.com/haskell-CI/haskell-ci
+#
+# version: 0.2
+#
+language: c
+dist: xenial
+
+git:
+  submodules: false  # whether to recursively clone submodules
+
+cache:
+  directories:
+    - $HOME/.cabal/packages
+    - $HOME/.cabal/store
+
+before_cache:
+  - rm -fv $CABALHOME/packages/hackage.haskell.org/build-reports.log
+  # remove files that are regenerated by 'cabal update'
+  - rm -fv $CABALHOME/packages/hackage.haskell.org/00-index.*
+  - rm -fv $CABALHOME/packages/hackage.haskell.org/*.json
+  - rm -fv $CABALHOME/packages/hackage.haskell.org/01-index.cache
+  - rm -fv $CABALHOME/packages/hackage.haskell.org/01-index.tar
+  - rm -fv $CABALHOME/packages/hackage.haskell.org/01-index.tar.idx
+
+  - rm -rfv $CABALHOME/packages/head.hackage
+
+matrix:
+  include:
+    - compiler: "ghc-8.6.3"
+      addons: {apt: {packages: [ghc-ppa-tools,cabal-install-2.4,ghc-8.6.3], sources: [hvr-ghc]}}
+    - compiler: "ghc-8.4.4"
+      addons: {apt: {packages: [ghc-ppa-tools,cabal-install-2.4,ghc-8.4.4], sources: [hvr-ghc]}}
+    - compiler: "ghc-8.2.2"
+      addons: {apt: {packages: [ghc-ppa-tools,cabal-install-2.4,ghc-8.2.2], sources: [hvr-ghc]}}
+    - compiler: "ghc-8.0.2"
+      addons: {apt: {packages: [ghc-ppa-tools,cabal-install-2.4,ghc-8.0.2], sources: [hvr-ghc]}}
+    - compiler: "ghc-7.10.3"
+      addons: {apt: {packages: [ghc-ppa-tools,cabal-install-2.4,ghc-7.10.3], sources: [hvr-ghc]}}
+    - compiler: "ghc-7.8.4"
+      addons: {apt: {packages: [ghc-ppa-tools,cabal-install-2.4,ghc-7.8.4], sources: [hvr-ghc]}}
+    - compiler: "ghc-7.6.3"
+      addons: {apt: {packages: [ghc-ppa-tools,cabal-install-2.4,ghc-7.6.3], sources: [hvr-ghc]}}
+    - compiler: "ghc-7.4.2"
+      addons: {apt: {packages: [ghc-ppa-tools,cabal-install-2.4,ghc-7.4.2], sources: [hvr-ghc]}}
+    - compiler: "ghc-head"
+      env: GHCHEAD=true
+      addons: {apt: {packages: [ghc-ppa-tools,cabal-install-head,ghc-head], sources: [hvr-ghc]}}
+
+  allow_failures:
+    - compiler: "ghc-head"
+
+before_install:
+  - HC=/opt/ghc/bin/${CC}
+  - HCPKG=${HC/ghc/ghc-pkg}
+  - unset CC
+  - CABAL=/opt/ghc/bin/cabal
+  - CABALHOME=$HOME/.cabal
+  - export PATH="$CABALHOME/bin:$PATH"
+  - ROOTDIR=$(pwd)
+  - HCNUMVER=$(( $(${HC} --numeric-version|sed -E 's/([0-9]+)\.([0-9]+)\.([0-9]+).*/\1 * 10000 + \2 * 100 + \3/') ))
+  - echo $HCNUMVER
+
+install:
+  - ${CABAL} --version
+  - echo "$(${HC} --version) [$(${HC} --print-project-git-commit-id 2> /dev/null || echo '?')]"
+  - TEST=--enable-tests
+  - BENCH=--enable-benchmarks
+  - GHCHEAD=${GHCHEAD-false}
+  - travis_retry ${CABAL} update -v
+  - sed -i.bak 's/^jobs:/-- jobs:/' $CABALHOME/config
+  - rm -fv cabal.project cabal.project.local
+  - "sed -i.bak 's/^-- jobs:.*/jobs: 2/' $CABALHOME/config"
+  # Overlay Hackage Package Index for GHC HEAD: https://github.com/hvr/head.hackage
+  - |
+    if $GHCHEAD; then
+      sed -i 's/-- allow-newer: .*/allow-newer: *:base/' $CABALHOME/config
+      for pkg in $($HCPKG list --simple-output); do pkg=$(echo $pkg | sed 's/-[^-]*$//'); sed -i "s/allow-newer: /allow-newer: *:$pkg, /" $CABALHOME/config; done
+
+      echo 'repository head.hackage'                                                        >> $CABALHOME/config
+      echo '   url: http://head.hackage.haskell.org/'                                       >> $CABALHOME/config
+      echo '   secure: True'                                                                >> $CABALHOME/config
+      echo '   root-keys: 07c59cb65787dedfaef5bd5f987ceb5f7e5ebf88b904bbd4c5cbdeb2ff71b740' >> $CABALHOME/config
+      echo '              2e8555dde16ebd8df076f1a8ef13b8f14c66bad8eafefd7d9e37d0ed711821fb' >> $CABALHOME/config
+      echo '              8f79fd2389ab2967354407ec852cbe73f2e8635793ac446d09461ffb99527f6e' >> $CABALHOME/config
+      echo '   key-threshold: 3'                                                            >> $CABALHOME.config
+
+      grep -Ev -- '^\s*--' $CABALHOME/config | grep -Ev '^\s*$'
+
+      ${CABAL} new-update head.hackage -v
+    fi
+  - grep -Ev -- '^\s*--' $CABALHOME/config | grep -Ev '^\s*$'
+  - rm -f cabal.project
+  - touch cabal.project
+  - "printf 'packages: \".\"\\n' >> cabal.project"
+  - "printf 'packages: \"./test\"\\n' >> cabal.project"
+  - "printf 'packages: \"./bench\"\\n' >> cabal.project"
+  - echo 'package primitive' >> cabal.project
+  - "echo '  ghc-options: -Wall' >> cabal.project"
+  - echo 'package primitive-tests' >> cabal.project
+  - "echo '  ghc-options: -Wall' >> cabal.project"
+  - echo 'package primitive-benchmarks' >> cabal.project
+  - "echo '  ghc-options: -Wall' >> cabal.project"
+  - echo 'package quickcheck-classes' >> cabal.project
+  - "echo '  flags: -aeson -semigroupoids -semirings' >> cabal.project"
+  - "printf 'write-ghc-environment-files: always\\n' >> cabal.project"
+  - touch cabal.project.local
+  - "for pkg in $($HCPKG list --simple-output); do echo $pkg | sed 's/-[^-]*$//' | grep -vE -- '^(primitive|primitive-benchmarks|primitive-tests)$' | sed 's/^/constraints: /' | sed 's/$/ installed/' >> cabal.project.local; done"
+  - cat cabal.project || true
+  - cat cabal.project.local || true
+  - if [ -f "./configure.ac" ]; then (cd "." && autoreconf -i); fi
+  - if [ -f "./test/configure.ac" ]; then (cd "./test" && autoreconf -i); fi
+  - if [ -f "./bench/configure.ac" ]; then (cd "./bench" && autoreconf -i); fi
+  - rm -f cabal.project.freeze
+  - rm -rf .ghc.environment.* "."/dist "./test"/dist "./bench"/dist
+  - DISTDIR=$(mktemp -d /tmp/dist-test.XXXX)
+
+# Here starts the actual work to be performed for the package under test;
+# any command which exits with a non-zero exit code causes the build to fail.
+script:
+  # test that source-distributions can be generated
+  - ${CABAL} new-sdist all
+  - mv dist-newstyle/sdist/*.tar.gz ${DISTDIR}/
+  - cd ${DISTDIR} || false
+  - find . -maxdepth 1 -name '*.tar.gz' -exec tar -xvf '{}' \;
+  - rm -f cabal.project
+  - touch cabal.project
+  - "printf 'packages: \"primitive-*/*.cabal\"\\n' >> cabal.project"
+  - "printf 'packages: \"primitive-tests-*/*.cabal\"\\n' >> cabal.project"
+  - "printf 'packages: \"primitive-benchmarks-*/*.cabal\"\\n' >> cabal.project"
+  - echo 'package primitive' >> cabal.project
+  - "echo '  ghc-options: -Wall' >> cabal.project"
+  - echo 'package primitive-tests' >> cabal.project
+  - "echo '  ghc-options: -Wall' >> cabal.project"
+  - echo 'package primitive-benchmarks' >> cabal.project
+  - "echo '  ghc-options: -Wall' >> cabal.project"
+  - echo 'package quickcheck-classes' >> cabal.project
+  - "echo '  flags: -aeson -semigroupoids -semirings' >> cabal.project"
+  - "printf 'write-ghc-environment-files: always\\n' >> cabal.project"
+  - touch cabal.project.local
+  - "for pkg in $($HCPKG list --simple-output); do echo $pkg | sed 's/-[^-]*$//' | grep -vE -- '^(primitive|primitive-benchmarks|primitive-tests)$' | sed 's/^/constraints: /' | sed 's/$/ installed/' >> cabal.project.local; done"
+  - cat cabal.project || true
+  - cat cabal.project.local || true
+
+  # build & run tests, build benchmarks
+  - ${CABAL} new-build -w ${HC} ${TEST} ${BENCH} all
+  - if [ "x$TEST" = "x--enable-tests" ]; then ${CABAL} new-test -w ${HC} ${TEST} ${BENCH} all; fi
+
+  # cabal check
+  - (cd primitive-* && ${CABAL} check)
+  - (cd primitive-tests-* && ${CABAL} check)
+  - (cd primitive-benchmarks-* && ${CABAL} check)
+
+  # haddock
+  - ${CABAL} new-haddock -w ${HC} ${TEST} ${BENCH} all
+
+# REGENDATA ["--output=.travis.yml","--config=cabal.haskell-ci","cabal.project"]
+# EOF
diff --git a/Control/Monad/Primitive.hs b/Control/Monad/Primitive.hs
index f182c18b..20195ef9 100644
--- a/Control/Monad/Primitive.hs
+++ b/Control/Monad/Primitive.hs
@@ -20,10 +20,10 @@ module Control.Monad.Primitive (
   liftPrim, primToPrim, primToIO, primToST, ioToPrim, stToPrim,
   unsafePrimToPrim, unsafePrimToIO, unsafePrimToST, unsafeIOToPrim,
   unsafeSTToPrim, unsafeInlinePrim, unsafeInlineIO, unsafeInlineST,
-  touch, evalPrim
+  touch, evalPrim, unsafeInterleave, unsafeDupableInterleave, noDuplicate
 ) where
 
-import GHC.Prim   ( State#, RealWorld, touch# )
+import GHC.Prim   ( State#, RealWorld, noDuplicate#, touch# )
 import GHC.Base   ( unsafeCoerce#, realWorld# )
 #if MIN_VERSION_base(4,4,0)
 import GHC.Base   ( seq# )
@@ -222,7 +222,7 @@ primToST :: PrimBase m => m a -> ST (PrimState m) a
 primToST = primToPrim
 
 -- | Convert an 'IO' action to a 'PrimMonad'.
--- 
+--
 -- @since 0.6.2.0
 ioToPrim :: (PrimMonad m, PrimState m ~ RealWorld) => IO a -> m a
 {-# INLINE ioToPrim #-}
@@ -252,9 +252,9 @@ unsafePrimToIO :: PrimBase m => m a -> IO a
 {-# INLINE unsafePrimToIO #-}
 unsafePrimToIO = unsafePrimToPrim
 
--- | Convert an 'ST' action with an arbitraty state token to any 'PrimMonad'.
+-- | Convert an 'ST' action with an arbitrary state token to any 'PrimMonad'.
 -- This operation is highly unsafe!
--- 
+--
 -- @since 0.6.2.0
 unsafeSTToPrim :: PrimMonad m => ST s a -> m a
 {-# INLINE unsafeSTToPrim #-}
@@ -296,3 +296,19 @@ evalPrim a = primitive (\s -> seq# a s)
 {-# NOINLINE evalPrim #-}
 evalPrim a = unsafePrimToPrim (evaluate a :: IO a)
 #endif
+
+noDuplicate :: PrimMonad m => m ()
+#if __GLASGOW_HASKELL__ >= 802
+noDuplicate = primitive $ \ s -> (# noDuplicate# s, () #)
+#else
+-- noDuplicate# was limited to RealWorld
+noDuplicate = primitive $ unsafeCoerce# $ \s -> (# noDuplicate# s, () #)
+#endif
+
+unsafeInterleave, unsafeDupableInterleave :: PrimBase m => m a -> m a
+unsafeInterleave x = unsafeDupableInterleave (noDuplicate >> x)
+unsafeDupableInterleave x = primitive $ \ s -> let r' = case internal x s of (# _, r #) -> r in (# s, r' #)
+{-# INLINE unsafeInterleave #-}
+{-# NOINLINE unsafeDupableInterleave #-}
+-- See Note [unsafeDupableInterleaveIO should not be inlined]
+-- in GHC.IO.Unsafe
diff --git a/Data/Primitive/Addr.hs b/Data/Primitive/Addr.hs
index 2ff25005..e4370e58 100644
--- a/Data/Primitive/Addr.hs
+++ b/Data/Primitive/Addr.hs
@@ -98,7 +98,7 @@ copyAddr (Addr dst#) (Addr src#) n
 -- | Copy the given number of bytes from the 'Addr' to the 'MutableByteArray'.
 --   The areas may not overlap. This function is only available when compiling
 --   with GHC 7.8 or newer.
---   
+--
 --   @since 0.6.4.0
 copyAddrToByteArray :: PrimMonad m
   => MutableByteArray (PrimState m) -- ^ destination
diff --git a/Data/Primitive/Array.hs b/Data/Primitive/Array.hs
index 13352f6c..e3abc13a 100644
--- a/Data/Primitive/Array.hs
+++ b/Data/Primitive/Array.hs
@@ -45,6 +45,7 @@ import Control.Monad.ST(ST,runST)
 
 import Control.Applicative
 import Control.Monad (MonadPlus(..), when)
+import qualified Control.Monad.Fail as Fail
 import Control.Monad.Fix
 #if MIN_VERSION_base(4,4,0)
 import Control.Monad.Zip
@@ -68,11 +69,16 @@ import GHC.Exts (runRW#)
 import GHC.Base (runRW#)
 #endif
 
+import Text.Read (Read (..), lexP, parens, prec)
+import Text.Read.Lex (Lexeme (Ident))
+import Text.ParserCombinators.ReadPrec (ReadPrec, readPrec_to_S, readS_to_Prec)
+import qualified Text.ParserCombinators.ReadPrec as ReadPrec
 import Text.ParserCombinators.ReadP
 
 #if MIN_VERSION_base(4,9,0) || MIN_VERSION_transformers(0,4,0)
 import Data.Functor.Classes (Eq1(..),Ord1(..),Show1(..),Read1(..))
 #endif
+import Control.Monad (liftM2)
 
 -- | Boxed arrays
 data Array a = Array
@@ -231,8 +237,12 @@ copyArray !dst !doff !src !soff !len = go 0
          | otherwise = return ()
 #endif
 
--- | Copy a slice of a mutable array to another array. The two arrays may
--- not be the same.
+-- | Copy a slice of a mutable array to another array. The two arrays must
+-- not be the same when using this library with GHC versions 7.6 and older.
+-- In GHC 7.8 and newer, overlapping arrays will behave correctly.
+--
+-- Note: The order of arguments is different from that of 'copyMutableArray#'. The primop
+-- has the source first while this wrapper has the destination first.
 copyMutableArray :: PrimMonad m
           => MutableArray (PrimState m) a    -- ^ destination array
           -> Int                             -- ^ offset into destination array
@@ -241,7 +251,7 @@ copyMutableArray :: PrimMonad m
           -> Int                             -- ^ number of elements to copy
           -> m ()
 {-# INLINE copyMutableArray #-}
-#if __GLASGOW_HASKELL__ >= 706
+#if __GLASGOW_HASKELL__ > 706
 -- NOTE: copyArray# and copyMutableArray# are slightly broken in GHC 7.6.* and earlier
 copyMutableArray (MutableArray dst#) (I# doff#)
                  (MutableArray src#) (I# soff#) (I# len#)
@@ -691,6 +701,11 @@ instance Monad Array where
      = copyArray smb off sb 0 (lsb)
          *> fill (off + lsb) sbs smb
 
+#if !(MIN_VERSION_base(4,13,0))
+  fail = Fail.fail
+#endif
+
+instance Fail.MonadFail Array where
   fail _ = empty
 
 instance MonadPlus Array where
@@ -779,28 +794,63 @@ instance Show1 Array where
 #endif
 #endif
 
-arrayLiftReadsPrec :: (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (Array a)
-arrayLiftReadsPrec _ listReadsPrec p = readParen (p > 10) . readP_to_S $ do
-  () <$ string "fromListN"
-  skipSpaces
-  n <- readS_to_P reads
-  skipSpaces
-  l <- readS_to_P listReadsPrec
-  return $ arrayFromListN n l
-
 instance Read a => Read (Array a) where
-  readsPrec = arrayLiftReadsPrec readsPrec readList
+  readPrec = arrayLiftReadPrec readPrec readListPrec
 
 #if MIN_VERSION_base(4,9,0) || MIN_VERSION_transformers(0,4,0)
 -- | @since 0.6.4.0
 instance Read1 Array where
-#if MIN_VERSION_base(4,9,0) || MIN_VERSION_transformers(0,5,0)
+#if MIN_VERSION_base(4,10,0)
+  liftReadPrec = arrayLiftReadPrec
+#elif MIN_VERSION_base(4,9,0) || MIN_VERSION_transformers(0,5,0)
   liftReadsPrec = arrayLiftReadsPrec
 #else
   readsPrec1 = arrayLiftReadsPrec readsPrec readList
 #endif
 #endif
 
+-- We're really forgiving here. We accept
+-- "[1,2,3]", "fromList [1,2,3]", and "fromListN 3 [1,2,3]".
+-- We consider fromListN with an invalid length to be an
+-- error, rather than a parse failure, because doing otherwise
+-- seems weird and likely to make debugging difficult.
+arrayLiftReadPrec :: ReadPrec a -> ReadPrec [a] -> ReadPrec (Array a)
+arrayLiftReadPrec _ read_list = parens $ prec app_prec $ ReadPrec.lift skipSpaces >>
+    ((fromList <$> read_list) ReadPrec.+++
+      do
+        tag <- ReadPrec.lift lexTag
+        case tag of
+          FromListTag -> fromList <$> read_list
+          FromListNTag -> liftM2 fromListN readPrec read_list)
+   where
+     app_prec = 10
+
+data Tag = FromListTag | FromListNTag
+
+-- Why don't we just use lexP? The general problem with lexP is that
+-- it doesn't always fail as fast as we might like. It will
+-- happily read to the end of an absurdly long lexeme (e.g., a 200MB string
+-- literal) before returning, at which point we'll immediately discard
+-- the result because it's not an identifier. Doing the job ourselves, we
+-- can see very quickly when we've run into a problem. We should also get
+-- a slight efficiency boost by going through the string just once.
+lexTag :: ReadP Tag
+lexTag = do
+  string "fromList"
+  s <- look
+  case s of
+    'N':c:_
+      | '0' <= c && c <= '9'
+      -> fail "" -- We have fromListN3 or similar
+      | otherwise -> FromListNTag <$ get -- Skip the 'N'
+    _ -> return FromListTag
+
+#if !MIN_VERSION_base(4,10,0)
+arrayLiftReadsPrec :: (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (Array a)
+arrayLiftReadsPrec reads_prec list_reads_prec = readPrec_to_S $
+  arrayLiftReadPrec (readS_to_Prec reads_prec) (readS_to_Prec (const list_reads_prec))
+#endif
+
 
 arrayDataType :: DataType
 arrayDataType = mkDataType "Data.Primitive.Array.Array" [fromListConstr]
diff --git a/Data/Primitive/ByteArray.hs b/Data/Primitive/ByteArray.hs
index 52720533..f82b24d1 100644
--- a/Data/Primitive/ByteArray.hs
+++ b/Data/Primitive/ByteArray.hs
@@ -208,7 +208,7 @@ sizeofByteArray :: ByteArray -> Int
 {-# INLINE sizeofByteArray #-}
 sizeofByteArray (ByteArray arr#) = I# (sizeofByteArray# arr#)
 
--- | Size of the mutable byte array in bytes. This function\'s behavior 
+-- | Size of the mutable byte array in bytes. This function\'s behavior
 -- is undefined if 'resizeMutableByteArray' is ever called on the mutable
 -- byte array given as the argument. Consequently, use of this function
 -- is discouraged. Prefer 'getSizeofMutableByteArray', which ensures correct
@@ -261,12 +261,13 @@ writeByteArray (MutableByteArray arr#) (I# i#) x
 
 -- | Right-fold over the elements of a 'ByteArray'.
 foldrByteArray :: forall a b. (Prim a) => (a -> b -> b) -> b -> ByteArray -> b
+{-# INLINE foldrByteArray #-}
 foldrByteArray f z arr = go 0
   where
     go i
-      | sizeofByteArray arr > i * sz = f (indexByteArray arr i) (go (i+1))
-      | otherwise                    = z
-    sz = sizeOf (undefined :: a)
+      | i < maxI  = f (indexByteArray arr i) (go (i+1))
+      | otherwise = z
+    maxI = sizeofByteArray arr `quot` sizeOf (undefined :: a)
 
 byteArrayFromList :: Prim a => [a] -> ByteArray
 byteArrayFromList xs = byteArrayFromListN (length xs) xs
@@ -461,7 +462,7 @@ instance Eq ByteArray where
 -- | Non-lexicographic ordering. This compares the lengths of
 -- the byte arrays first and uses a lexicographic ordering if
 -- the lengths are equal. Subject to change between major versions.
--- 
+--
 -- @since 0.6.3.0
 instance Ord ByteArray where
   ba1@(ByteArray ba1#) `compare` ba2@(ByteArray ba2#)
diff --git a/Data/Primitive/Internal/Operations.hs b/Data/Primitive/Internal/Operations.hs
index 091e11f5..0a942c87 100644
--- a/Data/Primitive/Internal/Operations.hs
+++ b/Data/Primitive/Internal/Operations.hs
@@ -17,13 +17,15 @@ module Data.Primitive.Internal.Operations (
   setWord64Array#, setWordArray#,
   setInt8Array#, setInt16Array#, setInt32Array#,
   setInt64Array#, setIntArray#,
-  setAddrArray#, setFloatArray#, setDoubleArray#, setWideCharArray#,
+  setAddrArray#, setStablePtrArray#, setFloatArray#, setDoubleArray#,
+  setWideCharArray#,
 
   setWord8OffAddr#, setWord16OffAddr#, setWord32OffAddr#,
   setWord64OffAddr#, setWordOffAddr#,
   setInt8OffAddr#, setInt16OffAddr#, setInt32OffAddr#,
   setInt64OffAddr#, setIntOffAddr#,
-  setAddrOffAddr#, setFloatOffAddr#, setDoubleOffAddr#, setWideCharOffAddr#
+  setAddrOffAddr#, setFloatOffAddr#, setDoubleOffAddr#, setWideCharOffAddr#,
+  setStablePtrOffAddr#
 ) where
 
 import Data.Primitive.MachDeps (Word64_#, Int64_#)
@@ -52,6 +54,8 @@ foreign import ccall unsafe "primitive-memops.h hsprimitive_memset_Word"
   setIntArray# :: MutableByteArray# s -> CPtrdiff -> CSize -> Int# -> IO ()
 foreign import ccall unsafe "primitive-memops.h hsprimitive_memset_Ptr"
   setAddrArray# :: MutableByteArray# s -> CPtrdiff -> CSize -> Addr# -> IO ()
+foreign import ccall unsafe "primitive-memops.h hsprimitive_memset_Ptr"
+  setStablePtrArray# :: MutableByteArray# s -> CPtrdiff -> CSize -> StablePtr# a -> IO ()
 foreign import ccall unsafe "primitive-memops.h hsprimitive_memset_Float"
   setFloatArray# :: MutableByteArray# s -> CPtrdiff -> CSize -> Float# -> IO ()
 foreign import ccall unsafe "primitive-memops.h hsprimitive_memset_Double"
@@ -81,6 +85,8 @@ foreign import ccall unsafe "primitive-memops.h hsprimitive_memset_Word"
   setIntOffAddr# :: Addr# -> CPtrdiff -> CSize -> Int# -> IO ()
 foreign import ccall unsafe "primitive-memops.h hsprimitive_memset_Ptr"
   setAddrOffAddr# :: Addr# -> CPtrdiff -> CSize -> Addr# -> IO ()
+foreign import ccall unsafe "primitive-memops.h hsprimitive_memset_Ptr"
+  setStablePtrOffAddr# :: Addr# -> CPtrdiff -> CSize -> StablePtr# a -> IO ()
 foreign import ccall unsafe "primitive-memops.h hsprimitive_memset_Float"
   setFloatOffAddr# :: Addr# -> CPtrdiff -> CSize -> Float# -> IO ()
 foreign import ccall unsafe "primitive-memops.h hsprimitive_memset_Double"
diff --git a/Data/Primitive/MutVar.hs b/Data/Primitive/MutVar.hs
index f707bfb6..8e871792 100644
--- a/Data/Primitive/MutVar.hs
+++ b/Data/Primitive/MutVar.hs
@@ -1,4 +1,4 @@
-{-# LANGUAGE MagicHash, UnboxedTuples, DeriveDataTypeable #-}
+{-# LANGUAGE MagicHash, UnboxedTuples, DeriveDataTypeable, CPP #-}
 
 -- |
 -- Module      : Data.Primitive.MutVar
@@ -25,8 +25,13 @@ module Data.Primitive.MutVar (
 ) where
 
 import Control.Monad.Primitive ( PrimMonad(..), primitive_ )
+#if MIN_VERSION_base(4,11,0)
+import GHC.Exts ( MutVar#, sameMutVar#, newMutVar#,
+                  readMutVar#, writeMutVar#, atomicModifyMutVar# )
+#else
 import GHC.Prim ( MutVar#, sameMutVar#, newMutVar#,
                   readMutVar#, writeMutVar#, atomicModifyMutVar# )
+#endif
 import Data.Primitive.Internal.Compat ( isTrue# )
 import Data.Typeable ( Typeable )
 
@@ -68,7 +73,8 @@ atomicModifyMutVar' mv f = do
   b <- atomicModifyMutVar mv force
   b `seq` return b
   where
-    force x = let (a, b) = f x in (a, a `seq` b)
+    force x = case f x of
+                v@(x',_) -> x' `seq` v
 
 -- | Mutate the contents of a 'MutVar'
 modifyMutVar :: PrimMonad m => MutVar (PrimState m) a -> (a -> a) -> m ()
@@ -83,4 +89,3 @@ modifyMutVar' :: PrimMonad m => MutVar (PrimState m) a -> (a -> a) -> m ()
 modifyMutVar' (MutVar mv#) g = primitive_ $ \s# ->
   case readMutVar# mv# s# of
     (# s'#, a #) -> let a' = g a in a' `seq` writeMutVar# mv# a' s'#
-
diff --git a/Data/Primitive/PrimArray.hs b/Data/Primitive/PrimArray.hs
index 33d81c20..50d10fdb 100644
--- a/Data/Primitive/PrimArray.hs
+++ b/Data/Primitive/PrimArray.hs
@@ -6,7 +6,6 @@
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE UnboxedTuples #-}
 
-{-# OPTIONS_GHC -Wall #-}
 
 -- |
 -- Module      : Data.Primitive.PrimArray
@@ -159,9 +158,10 @@ instance (Eq a, Prim a) => Eq (PrimArray a) where
     loop !i
       | i < 0 = True
       | otherwise = indexPrimArray a1 i == indexPrimArray a2 i && loop (i-1)
+  {-# INLINE (==) #-}
 
 -- | Lexicographic ordering. Subject to change between major versions.
--- 
+--
 --   @since 0.6.4.0
 instance (Ord a, Prim a) => Ord (PrimArray a) where
   compare a1@(PrimArray ba1#) a2@(PrimArray ba2#)
@@ -174,6 +174,7 @@ instance (Ord a, Prim a) => Ord (PrimArray a) where
     loop !i
       | i < sz = compare (indexPrimArray a1 i) (indexPrimArray a2 i) <> loop (i+1)
       | otherwise = compare sz1 sz2
+  {-# INLINE compare #-}
 
 #if MIN_VERSION_base(4,7,0)
 -- | @since 0.6.4.0
@@ -252,7 +253,7 @@ emptyPrimArray = runST $ primitive $ \s0# -> case newByteArray# 0# s0# of
 newPrimArray :: forall m a. (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)
 {-# INLINE newPrimArray #-}
 newPrimArray (I# n#)
-  = primitive (\s# -> 
+  = primitive (\s# ->
       case newByteArray# (n# *# sizeOf# (undefined :: a)) s# of
         (# s'#, arr# #) -> (# s'#, MutablePrimArray arr# #)
     )
@@ -328,7 +329,7 @@ copyMutablePrimArray :: forall m a.
 {-# INLINE copyMutablePrimArray #-}
 copyMutablePrimArray (MutablePrimArray dst#) (I# doff#) (MutablePrimArray src#) (I# soff#) (I# n#)
   = primitive_ (copyMutableByteArray#
-      src# 
+      src#
       (soff# *# (sizeOf# (undefined :: a)))
       dst#
       (doff# *# (sizeOf# (undefined :: a)))
@@ -347,7 +348,7 @@ copyPrimArray :: forall m a.
 {-# INLINE copyPrimArray #-}
 copyPrimArray (MutablePrimArray dst#) (I# doff#) (PrimArray src#) (I# soff#) (I# n#)
   = primitive_ (copyByteArray#
-      src# 
+      src#
       (soff# *# (sizeOf# (undefined :: a)))
       dst#
       (doff# *# (sizeOf# (undefined :: a)))
@@ -412,7 +413,7 @@ getSizeofMutablePrimArray :: forall m a. (PrimMonad m, Prim a)
 {-# INLINE getSizeofMutablePrimArray #-}
 #if __GLASGOW_HASKELL__ >= 801
 getSizeofMutablePrimArray (MutablePrimArray arr#)
-  = primitive (\s# -> 
+  = primitive (\s# ->
       case getSizeofMutableByteArray# arr# s# of
         (# s'#, sz# #) -> (# s'#, I# (quotInt# sz# (sizeOf# (undefined :: a))) #)
     )
@@ -539,7 +540,7 @@ foldlPrimArrayM' f z0 arr = go 0 z0
 -- > incrPositiveB xs = runST $ runMaybeT $ traversePrimArrayP
 -- >   (\x -> bool (MaybeT (return Nothing)) (MaybeT (return (Just (x + 1)))) (x > 0))
 -- >   xs
--- 
+--
 -- Benchmarks demonstrate that the second implementation runs 150 times
 -- faster than the first. It also results in fewer allocations.
 {-# INLINE traversePrimArrayP #-}
diff --git a/Data/Primitive/Ptr.hs b/Data/Primitive/Ptr.hs
index d93ae9ac..716cae95 100644
--- a/Data/Primitive/Ptr.hs
+++ b/Data/Primitive/Ptr.hs
@@ -118,7 +118,7 @@ copyPtrToMutablePrimArray :: forall m a. (PrimMonad m, Prim a)
   -> Int -- ^ number of elements
   -> m ()
 {-# INLINE copyPtrToMutablePrimArray #-}
-copyPtrToMutablePrimArray (MutablePrimArray ba#) (I# doff#) (Ptr addr#) (I# n#) = 
+copyPtrToMutablePrimArray (MutablePrimArray ba#) (I# doff#) (Ptr addr#) (I# n#) =
   primitive_ (copyAddrToByteArray# addr# ba# (doff# *# siz#) (n# *# siz#))
   where
   siz# = sizeOf# (undefined :: a)
diff --git a/Data/Primitive/SmallArray.hs b/Data/Primitive/SmallArray.hs
index 3a50cf21..7e0eb413 100644
--- a/Data/Primitive/SmallArray.hs
+++ b/Data/Primitive/SmallArray.hs
@@ -74,6 +74,7 @@ import qualified GHC.Exts
 
 import Control.Applicative
 import Control.Monad
+import qualified Control.Monad.Fail as Fail
 import Control.Monad.Fix
 import Control.Monad.Primitive
 import Control.Monad.ST
@@ -808,6 +809,11 @@ instance Monad SmallArray where
      copySmallArray smb off sb 0 (length sb)
        *> fill (off + length sb) sbs smb
 
+#if !(MIN_VERSION_base(4,13,0))
+  fail = Fail.fail
+#endif
+
+instance Fail.MonadFail SmallArray where
   fail _ = emptySmallArray
 
 instance MonadPlus SmallArray where
diff --git a/Data/Primitive/Types.hs b/Data/Primitive/Types.hs
index fd36ea0c..6418d7c5 100644
--- a/Data/Primitive/Types.hs
+++ b/Data/Primitive/Types.hs
@@ -3,6 +3,7 @@
 {-# LANGUAGE ScopedTypeVariables #-}
 #if __GLASGOW_HASKELL__ >= 800
 {-# LANGUAGE TypeInType #-}
+{-# LANGUAGE DeriveGeneric #-}
 #endif
 
 #include "HsBaseConfig.h"
@@ -48,6 +49,9 @@ import GHC.Int (
 import GHC.Ptr (
     Ptr(..), FunPtr(..)
   )
+import GHC.Stable (
+    StablePtr(..)
+  )
 
 import GHC.Prim
 #if __GLASGOW_HASKELL__ >= 706
@@ -62,8 +66,34 @@ import Numeric
 
 import qualified Foreign.Storable as FS
 
+import Control.Applicative (Const(..))
+#if MIN_VERSION_base(4,8,0)
+import Data.Functor.Identity (Identity(..))
+import qualified Data.Monoid as Monoid
+#endif
+#if MIN_VERSION_base(4,6,0)
+import Data.Ord (Down(..))
+#else
+import GHC.Exts (Down(..))
+#endif
+#if MIN_VERSION_base(4,9,0)
+import qualified Data.Semigroup as Semigroup
+#endif
+#if __GLASGOW_HASKELL__ >= 800
+import GHC.Generics
+#endif
+
 -- | A machine address
-data Addr = Addr Addr# deriving ( Typeable )
+data Addr = Addr Addr#
+
+#if __GLASGOW_HASKELL__ < 710
+deriving instance Typeable Addr
+#endif
+
+#if __GLASGOW_HASKELL__ >= 800
+-- | @since TODO
+deriving instance Generic Addr
+#endif
 
 instance Show Addr where
   showsPrec _ (Addr a) =
@@ -294,6 +324,9 @@ derivePrim(Addr, Addr, sIZEOF_PTR, aLIGNMENT_PTR,
 derivePrim(Ptr a, Ptr, sIZEOF_PTR, aLIGNMENT_PTR,
            indexAddrArray#, readAddrArray#, writeAddrArray#, setAddrArray#,
            indexAddrOffAddr#, readAddrOffAddr#, writeAddrOffAddr#, setAddrOffAddr#)
+derivePrim(StablePtr a, StablePtr, sIZEOF_PTR, aLIGNMENT_PTR,
+           indexStablePtrArray#, readStablePtrArray#, writeStablePtrArray#, setStablePtrArray#,
+           indexStablePtrOffAddr#, readStablePtrOffAddr#, writeStablePtrOffAddr#, setStablePtrOffAddr#)
 derivePrim(FunPtr a, FunPtr, sIZEOF_PTR, aLIGNMENT_PTR,
            indexAddrArray#, readAddrArray#, writeAddrArray#, setAddrArray#,
            indexAddrOffAddr#, readAddrOffAddr#, writeAddrOffAddr#, setAddrOffAddr#)
@@ -393,3 +426,28 @@ deriving instance Prim CKey
 deriving instance Prim CTimer
 #endif
 deriving instance Prim Fd
+
+-- | @since 0.6.5.0
+deriving instance Prim a => Prim (Const a b)
+-- | @since 0.6.5.0
+deriving instance Prim a => Prim (Down a)
+#if MIN_VERSION_base(4,8,0)
+-- | @since 0.6.5.0
+deriving instance Prim a => Prim (Identity a)
+-- | @since 0.6.5.0
+deriving instance Prim a => Prim (Monoid.Dual a)
+-- | @since 0.6.5.0
+deriving instance Prim a => Prim (Monoid.Sum a)
+-- | @since 0.6.5.0
+deriving instance Prim a => Prim (Monoid.Product a)
+#endif
+#if MIN_VERSION_base(4,9,0)
+-- | @since 0.6.5.0
+deriving instance Prim a => Prim (Semigroup.First a)
+-- | @since 0.6.5.0
+deriving instance Prim a => Prim (Semigroup.Last a)
+-- | @since 0.6.5.0
+deriving instance Prim a => Prim (Semigroup.Min a)
+-- | @since 0.6.5.0
+deriving instance Prim a => Prim (Semigroup.Max a)
+#endif
diff --git a/Data/Primitive/Types/PrimUnlifted.hs b/Data/Primitive/Types/PrimUnlifted.hs
new file mode 100644
index 00000000..1387e3fc
--- /dev/null
+++ b/Data/Primitive/Types/PrimUnlifted.hs
@@ -0,0 +1,352 @@
+{-# language CPP #-}
+{-# language MagicHash #-}
+{-# language TypeFamilies #-}
+{-# language DataKinds #-}
+{-# language DefaultSignatures #-}
+{-# language ScopedTypeVariables #-}
+
+-- |
+-- Module      : Data.Primitive.UnliftedArray
+-- Copyright   : (c) Dan Doel 2016, (c) David Feuer 2018
+-- License     : BSD-style
+--
+-- Maintainer  : Libraries <libraries@haskell.org>
+-- Portability : non-portable
+--
+-- Note: In a previous release, there was a `PrimUnlifted` instance for
+-- `StablePtr`. However, since `StablePtr#` is not of kind `TYPE UnliftedRep`,
+-- and is treated very differently by the garbage collector, this instance was
+-- unsound, and it has been removed.
+--
+-- @since TODO
+
+module Data.Primitive.Types.PrimUnlifted
+ ( PrimUnlifted (..)
+#if __GLASGOW_HASKELL__ < 800
+ , Unlifted
+ , toUnlifted#
+ , fromUnlifted#
+#endif
+ ) where
+
+import GHC.Exts
+
+import Data.Primitive.PrimArray (PrimArray (..), MutablePrimArray (..))
+import Data.Primitive.Array (Array (..), MutableArray (..))
+import Data.Primitive.SmallArray (SmallArray (..), SmallMutableArray (..))
+import Data.Primitive.ByteArray (ByteArray (..), MutableByteArray (..))
+import Data.Primitive.MutVar (MutVar (..))
+import GHC.MVar (MVar(..))
+import GHC.Conc (TVar(..))
+import GHC.Weak (Weak(..))
+import GHC.Conc.Sync (ThreadId(..))
+#if MIN_VERSION_base(4,12,0)
+import GHC.StableName (StableName (..))
+#else
+import System.Mem.StableName (StableName)
+import Unsafe.Coerce (unsafeCoerce)
+#endif
+
+-- | Classifies the types that are just liftings of unlifted pointer
+-- types.
+--
+-- For GHC versions 8.0 and later, instances should define 'Unlift',
+-- 'toUnlifted#', and 'fromUnlifted#'. When compiled with earlier versions,
+-- @Unlifted a@ is always a synonym for 'ArrayArray#', and instances should
+-- define 'toArrayArray#' and 'fromArrayArray#', coercing the internal
+-- unlifted types to and from 'ArrayArray#'.
+--
+-- Note: 'toArrayArray#' and 'fromArrayArray#' will eventually be
+-- deprecated and removed. They should be used /only/ to define instances
+-- for GHC versions before 8.0.
+class PrimUnlifted a where
+#if __GLASGOW_HASKELL__ >= 800
+  -- Technically speaking, this is too strong; users *can* write
+  -- working instances with just toArrayArray# and fromArrayArray#.
+  -- But we really want to push them in the right direction for the
+  -- future.
+  {-# MINIMAL toUnlifted#, fromUnlifted# #-}
+  -- | The unlifted pointer representation of a type. For example, since
+  -- 'MutVar' is defined
+  --
+  -- @
+  -- data MutVar s a = MutVar (MutVar# s a)
+  -- @
+  --
+  -- we define
+  --
+  -- @
+  -- type Unlifted (MutVar s a) = MutVar# s a
+  -- @
+  --
+  -- @since TODO
+#  if __GLASGOW_HASKELL__ >= 802
+  type Unlifted a :: TYPE 'UnliftedRep
+#  else
+  type Unlifted a :: TYPE 'PtrRepUnlifted
+#  endif
+  type Unlifted a = ArrayArray#
+
+  -- | Convert a value to its unlifted representation.
+  --
+  -- @since TODO
+  toUnlifted# :: a -> Unlifted a
+  default toUnlifted#
+    :: Unlifted a ~ ArrayArray#
+    => a -> Unlifted a
+  toUnlifted# = toArrayArray#
+
+  -- Convert a value from its unlifted representation.
+  --
+  -- @since TODO
+  fromUnlifted# :: Unlifted a -> a
+  default fromUnlifted#
+    :: Unlifted a ~ ArrayArray#
+    => Unlifted a -> a
+  fromUnlifted# = fromArrayArray#
+#elif __GLASGOW_HASKELL__ >= 708
+  {-# MINIMAL toArrayArray#, fromArrayArray# #-}
+#endif
+
+  -- | Convert the value to an 'ArrayArray#'.
+  toArrayArray# :: a -> ArrayArray#
+#if __GLASGOW_HASKELL__ >= 800
+  toArrayArray# a = unsafeCoerce# (toUnlifted# a)
+#endif
+
+  -- | Convert an 'ArrayArray#' to the value.
+  fromArrayArray# :: ArrayArray# -> a
+#if __GLASGOW_HASKELL__ >= 800
+  fromArrayArray# a# = fromUnlifted# (unsafeCoerce# a#)
+#endif
+
+#if __GLASGOW_HASKELL__ < 800
+-- | For GHC versions below 8.0, we define @Unlifted a = ArrayArray#@
+-- regardless of the true type structure. This is necessary because
+-- earlier versions don't allow a type family to produce an unlifted
+-- result. Users should always prefer 'Unlift' to 'ArrayArray#' for
+-- forwards compatibility.
+type Unlifted a = ArrayArray#
+
+-- Why do we define these as functions instead of class methods with
+-- defaults when __GLASGOW_HASKELL__ < 800? Some users feel virtuous
+-- when they define all the methods for a class, even when there are
+-- defaults. Such a user might be sorely tempted to define 'toUnlifted#'
+-- and 'fromUnlifted#' the same as 'toArrayArray#' and 'fromArrayArray#'.
+-- That ugly code will continue to compile and run correctly under
+-- later GHC versions, and never get fixed. Since there's no point
+-- in allowing that, we just don't.
+
+-- | Convert a value to its unlifted representation.
+toUnlifted# :: PrimUnlifted a => a -> Unlifted a
+toUnlifted# = toArrayArray#
+
+-- | Convert a value from its unlifted representation.
+fromUnlifted# :: PrimUnlifted a => Unlifted a -> a
+fromUnlifted# = fromArrayArray#
+#endif
+
+instance PrimUnlifted (Array a) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (Array a) = Array# a
+
+  toUnlifted# (Array aa#) = aa#
+  fromUnlifted# aa# = Array aa#
+#else
+  toArrayArray# (Array a#) = unsafeCoerce# a#
+  fromArrayArray# aa# = Array (unsafeCoerce# aa#)
+#endif
+
+instance PrimUnlifted (MutableArray s a) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (MutableArray s a) = MutableArray# s a
+
+  toUnlifted# (MutableArray ma#) = ma#
+  fromUnlifted# aa# = MutableArray aa#
+#else
+  toArrayArray# (MutableArray ma#) = unsafeCoerce# ma#
+  fromArrayArray# aa# = MutableArray (unsafeCoerce# aa#)
+#endif
+
+instance PrimUnlifted ByteArray where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted ByteArray = ByteArray#
+
+  toUnlifted# (ByteArray ba#) = ba#
+  fromUnlifted# ba# = ByteArray ba#
+#else
+  toArrayArray# (ByteArray ba#) = unsafeCoerce# ba#
+  fromArrayArray# aa# = ByteArray (unsafeCoerce# aa#)
+#endif
+
+instance PrimUnlifted (MutableByteArray s) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (MutableByteArray s) = MutableByteArray# s
+
+  toUnlifted# (MutableByteArray ba#) = ba#
+  fromUnlifted# ba# = MutableByteArray ba#
+#else
+  toArrayArray# (MutableByteArray mba#) = unsafeCoerce# mba#
+  fromArrayArray# aa# = MutableByteArray (unsafeCoerce# aa#)
+#endif
+
+-- | @since 0.6.4.0
+instance PrimUnlifted (PrimArray a) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (PrimArray a) = ByteArray#
+
+  toUnlifted# (PrimArray ba#) = ba#
+  fromUnlifted# ba# = PrimArray ba#
+#else
+  toArrayArray# (PrimArray ba#) = unsafeCoerce# ba#
+  fromArrayArray# aa# = PrimArray (unsafeCoerce# aa#)
+#endif
+
+-- | @since 0.6.4.0
+instance PrimUnlifted (MutablePrimArray s a) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (MutablePrimArray s a) = MutableByteArray# s
+
+  toUnlifted# (MutablePrimArray ba#) = ba#
+  fromUnlifted# ba# = MutablePrimArray ba#
+#else
+  toArrayArray# (MutablePrimArray mba#) = unsafeCoerce# mba#
+  fromArrayArray# aa# = MutablePrimArray (unsafeCoerce# aa#)
+#endif
+
+instance PrimUnlifted (SmallArray a) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (SmallArray a) = SmallArray# a
+
+  toUnlifted# (SmallArray sa#) = sa#
+  fromUnlifted# = SmallArray
+#elif __GLASGOW_HASKELL__ >= 710
+  toArrayArray# (SmallArray sa#) =
+    unsafeCoerce# (sa# :: SmallArray# a)
+  fromArrayArray# aa# =
+    SmallArray (unsafeCoerce# aa# :: SmallArray# a)
+#else
+  -- SmallArray is a newtype
+  toArrayArray# (SmallArray ar) = toArrayArray# ar
+  fromArrayArray# aa# = SmallArray (fromArrayArray# aa#)
+#endif
+
+instance PrimUnlifted (SmallMutableArray s a) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (SmallMutableArray s a) = SmallMutableArray# s a
+
+  toUnlifted# (SmallMutableArray sa#) = sa#
+  fromUnlifted# = SmallMutableArray
+#elif __GLASGOW_HASKELL__ >= 710
+  toArrayArray# (SmallMutableArray sma#) =
+    unsafeCoerce# (sma# :: SmallMutableArray# s a)
+  fromArrayArray# aa# =
+    SmallMutableArray (unsafeCoerce# aa# :: SmallMutableArray# s a)
+#else
+  -- SmallMutableArray is a newtype
+  toArrayArray# (SmallMutableArray ar) = toArrayArray# ar
+  fromArrayArray# aa# = SmallMutableArray (fromArrayArray# aa#)
+#endif
+
+instance PrimUnlifted (MutVar s a) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (MutVar s a) = MutVar# s a
+
+  toUnlifted# (MutVar ref) = ref
+  fromUnlifted# = MutVar
+#else
+  toArrayArray# (MutVar mv#) = unsafeCoerce# mv#
+  fromArrayArray# aa# = MutVar (unsafeCoerce# aa#)
+#endif
+
+-- | @since 0.6.4.0
+instance PrimUnlifted (MVar a) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (MVar a) = MVar# RealWorld a
+
+  toUnlifted# (MVar mv#) = mv#
+  fromUnlifted# = MVar
+#else
+  toArrayArray# (MVar mv#) = unsafeCoerce# mv#
+  fromArrayArray# mv# = MVar (unsafeCoerce# mv#)
+#endif
+
+-- | @since 0.6.4.0
+instance PrimUnlifted (TVar a) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (TVar a) = TVar# RealWorld a
+
+  toUnlifted# (TVar tv#) = tv#
+  fromUnlifted# = TVar
+#else
+  toArrayArray# (TVar tv#) = unsafeCoerce# tv#
+  fromArrayArray# tv# = TVar (unsafeCoerce# tv#)
+#endif
+
+-- | @since 0.6.4.0
+instance PrimUnlifted (Weak a) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (Weak a) = Weak# a
+
+  toUnlifted# (Weak wk#) = wk#
+  fromUnlifted# = Weak
+#else
+  toArrayArray# (Weak tv#) = unsafeCoerce# tv#
+  fromArrayArray# tv# = Weak (unsafeCoerce# tv#)
+#endif
+
+-- | @since 0.6.4.0
+instance PrimUnlifted ThreadId where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted ThreadId = ThreadId#
+
+  toUnlifted# (ThreadId tid#) = tid#
+  fromUnlifted# = ThreadId
+#else
+  toArrayArray# (ThreadId tv#) = unsafeCoerce# tv#
+  fromArrayArray# tv# = ThreadId (unsafeCoerce# tv#)
+#endif
+
+-- | @since TODO
+instance PrimUnlifted (StableName a) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (StableName a) = StableName# a
+
+#  if MIN_VERSION_base(4,12,0)
+  toUnlifted# (StableName sn) = sn
+  fromUnlifted# = StableName
+#  else
+  toUnlifted# sn = toUnlifted# (toStableName_ sn)
+  fromUnlifted# sn# = fromStableName_ (fromUnlifted# sn#)
+#  endif
+
+#else
+  toArrayArray# sn = toArrayArray# (toStableName_ sn)
+  fromArrayArray# sn = fromStableName_ (fromArrayArray# sn)
+#endif
+
+#if !MIN_VERSION_base(4,12,0)
+-- This is a disgusting hack. The trouble is that StableName
+-- used to be defined in System.Mem.StableName and exported *abstractly*.
+-- There was no legitimate way to convert between a StableName and
+-- a StableName#! See Trac #15535.
+toStableName_ :: StableName a -> StableName_ a
+toStableName_ = unsafeCoerce
+
+fromStableName_ :: StableName_ a -> StableName a
+fromStableName_ = unsafeCoerce
+
+-- An exact copy of StableName whose constructor we can access.
+data StableName_ a = StableName_ (StableName# a)
+
+instance PrimUnlifted (StableName_ a) where
+#  if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (StableName_ a) = StableName# a
+
+  toUnlifted# (StableName_ sn#) = sn#
+  fromUnlifted# sn# = StableName_ sn#
+#  else
+  toArrayArray# (StableName_ sn#) = unsafeCoerce# sn#
+  fromArrayArray# sn# = StableName_ (unsafeCoerce# sn#)
+#  endif
+#endif
diff --git a/Data/Primitive/UnliftedArray.hs b/Data/Primitive/UnliftedArray.hs
index 75a48473..39deddf0 100644
--- a/Data/Primitive/UnliftedArray.hs
+++ b/Data/Primitive/UnliftedArray.hs
@@ -47,7 +47,13 @@ module Data.Primitive.UnliftedArray
   ( -- * Types
     UnliftedArray(..)
   , MutableUnliftedArray(..)
-  , PrimUnlifted(..)
+  -- We don't *really* want to export the PrimUnlifted methods from
+  -- this module anymore; users should import Data.Primitive.Types.PrimUnlifted
+  -- to define PrimUnlifted instances or use PrimUnlifted methods. But since
+  -- this module used to define PrimUnlifted, we need to export the *legacy*
+  -- methods for backwards compatibility. Eventually (a couple versions
+  -- after we stop supporting GHC <8.0), we can quit doing that.
+  , PrimUnlifted(toArrayArray#, fromArrayArray#)
     -- * Operations
   , unsafeNewUnliftedArray
   , newUnliftedArray
@@ -82,33 +88,27 @@ module Data.Primitive.UnliftedArray
 --  , unsafeThawUnliftedArray
   ) where
 
+#if __GLASGOW_HASKELL__ < 710
 import Data.Typeable
 import Control.Applicative
+#endif
 
-import GHC.Prim
+import GHC.Exts
 import GHC.Base (Int(..),build)
 
 import Control.Monad.Primitive
 
+#if !MIN_VERSION_base(4,9,0)
 import Control.Monad.ST (runST,ST)
+#else
+import Control.Monad.ST (ST)
+#endif
 
-import Data.Monoid (Monoid,mappend)
+import Data.Monoid (Monoid (..))
 import Data.Primitive.Internal.Compat ( isTrue# )
 
+import Data.Primitive.Types.PrimUnlifted
 import qualified Data.List as L
-import           Data.Primitive.Array (Array)
-import qualified Data.Primitive.Array as A
-import           Data.Primitive.ByteArray (ByteArray)
-import qualified Data.Primitive.ByteArray as BA
-import qualified Data.Primitive.PrimArray as PA
-import qualified Data.Primitive.SmallArray as SA
-import qualified Data.Primitive.MutVar as MV
-import qualified Data.Monoid
-import qualified GHC.MVar as GM (MVar(..))
-import qualified GHC.Conc as GC (TVar(..))
-import qualified GHC.Stable as GSP (StablePtr(..))
-import qualified GHC.Weak as GW (Weak(..))
-import qualified GHC.Conc.Sync as GCS (ThreadId(..))
 import qualified GHC.Exts as E
 import qualified GHC.ST as GHCST
 
@@ -127,92 +127,43 @@ import GHC.Base (runRW#)
 -- around unlifted primitive types. The values of the unlifted type are
 -- stored directly, eliminating a layer of indirection.
 data UnliftedArray e = UnliftedArray ArrayArray#
+#if __GLASGOW_HASKELL__ < 710
   deriving (Typeable)
+#endif
+
+instance PrimUnlifted (UnliftedArray e) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (UnliftedArray e) = ArrayArray#
+
+  toUnlifted# (UnliftedArray aa#) = aa#
+  fromUnlifted# aa# = UnliftedArray aa#
+#endif
+  -- Unlike all other PrimUnlifted instances, we implement
+  -- the legacy methods regardless of GHC version because
+  -- we can avoid unsafe coercions altogether. It shouldn't
+  -- really matter, but it seems cleaner.
+  toArrayArray# (UnliftedArray aa#) = aa#
+  fromArrayArray# aa# = UnliftedArray aa#
 
 -- | Mutable arrays that efficiently store types that are simple wrappers
 -- around unlifted primitive types. The values of the unlifted type are
 -- stored directly, eliminating a layer of indirection.
 data MutableUnliftedArray s e = MutableUnliftedArray (MutableArrayArray# s)
+#if __GLASGOW_HASKELL__ < 710
   deriving (Typeable)
-
--- | Classifies the types that are able to be stored in 'UnliftedArray' and
--- 'MutableUnliftedArray'. These should be types that are just liftings of the
--- unlifted pointer types, so that their internal contents can be safely coerced
--- into an 'ArrayArray#'.
-class PrimUnlifted a where
-  toArrayArray# :: a -> ArrayArray#
-  fromArrayArray# :: ArrayArray# -> a
-
-instance PrimUnlifted (UnliftedArray e) where
-  toArrayArray# (UnliftedArray aa#) = aa#
-  fromArrayArray# aa# = UnliftedArray aa#
+#endif
 
 instance PrimUnlifted (MutableUnliftedArray s e) where
+#if __GLASGOW_HASKELL__ >= 800
+  type Unlifted (MutableUnliftedArray s e) = MutableArrayArray# s
+
+  toUnlifted# (MutableUnliftedArray maa#) = maa#
+  fromUnlifted# aa# = MutableUnliftedArray aa#
+#else
   toArrayArray# (MutableUnliftedArray maa#) = unsafeCoerce# maa#
   fromArrayArray# aa# = MutableUnliftedArray (unsafeCoerce# aa#)
+#endif
 
-instance PrimUnlifted (Array a) where
-  toArrayArray# (A.Array a#) = unsafeCoerce# a#
-  fromArrayArray# aa# = A.Array (unsafeCoerce# aa#)
-
-instance PrimUnlifted (A.MutableArray s a) where
-  toArrayArray# (A.MutableArray ma#) = unsafeCoerce# ma#
-  fromArrayArray# aa# = A.MutableArray (unsafeCoerce# aa#)
-
-instance PrimUnlifted ByteArray where
-  toArrayArray# (BA.ByteArray ba#) = unsafeCoerce# ba#
-  fromArrayArray# aa# = BA.ByteArray (unsafeCoerce# aa#)
-
-instance PrimUnlifted (BA.MutableByteArray s) where
-  toArrayArray# (BA.MutableByteArray mba#) = unsafeCoerce# mba#
-  fromArrayArray# aa# = BA.MutableByteArray (unsafeCoerce# aa#)
-
--- | @since 0.6.4.0
-instance PrimUnlifted (PA.PrimArray a) where
-  toArrayArray# (PA.PrimArray ba#) = unsafeCoerce# ba#
-  fromArrayArray# aa# = PA.PrimArray (unsafeCoerce# aa#)
-
--- | @since 0.6.4.0
-instance PrimUnlifted (PA.MutablePrimArray s a) where
-  toArrayArray# (PA.MutablePrimArray mba#) = unsafeCoerce# mba#
-  fromArrayArray# aa# = PA.MutablePrimArray (unsafeCoerce# aa#)
-
-instance PrimUnlifted (SA.SmallArray a) where
-  toArrayArray# (SA.SmallArray sa#) = unsafeCoerce# sa#
-  fromArrayArray# aa# = SA.SmallArray (unsafeCoerce# aa#)
-
-instance PrimUnlifted (SA.SmallMutableArray s a) where
-  toArrayArray# (SA.SmallMutableArray sma#) = unsafeCoerce# sma#
-  fromArrayArray# aa# = SA.SmallMutableArray (unsafeCoerce# aa#)
-
-instance PrimUnlifted (MV.MutVar s a) where
-  toArrayArray# (MV.MutVar mv#) = unsafeCoerce# mv#
-  fromArrayArray# aa# = MV.MutVar (unsafeCoerce# aa#)
-
--- | @since 0.6.4.0
-instance PrimUnlifted (GM.MVar a) where
-  toArrayArray# (GM.MVar mv#) = unsafeCoerce# mv#
-  fromArrayArray# mv# = GM.MVar (unsafeCoerce# mv#)
-
--- | @since 0.6.4.0
-instance PrimUnlifted (GC.TVar a) where
-  toArrayArray# (GC.TVar tv#) = unsafeCoerce# tv#
-  fromArrayArray# tv# = GC.TVar (unsafeCoerce# tv#)
-
--- | @since 0.6.4.0
-instance PrimUnlifted (GSP.StablePtr a) where
-  toArrayArray# (GSP.StablePtr tv#) = unsafeCoerce# tv#
-  fromArrayArray# tv# = GSP.StablePtr (unsafeCoerce# tv#)
-
--- | @since 0.6.4.0
-instance PrimUnlifted (GW.Weak a) where
-  toArrayArray# (GW.Weak tv#) = unsafeCoerce# tv#
-  fromArrayArray# tv# = GW.Weak (unsafeCoerce# tv#)
-
--- | @since 0.6.4.0
-instance PrimUnlifted GCS.ThreadId where
-  toArrayArray# (GCS.ThreadId tv#) = unsafeCoerce# tv#
-  fromArrayArray# tv# = GCS.ThreadId (unsafeCoerce# tv#)
 
 die :: String -> String -> a
 die fun problem = error $ "Data.Primitive.UnliftedArray." ++ fun ++ ": " ++ problem
diff --git a/README.md b/README.md
new file mode 100644
index 00000000..bf2cd6c7
--- /dev/null
+++ b/README.md
@@ -0,0 +1,12 @@
+The `primitive` package [![Build Status](https://travis-ci.org/haskell/primitive.png?branch=master)](https://travis-ci.org/haskell/primitive)
+=======================
+
+This package provides various primitive memory-related operations for Haskell.
+
+See [`primitive` on Hackage](http://hackage.haskell.org/package/primitive) for more information.
+
+
+## how to test and benchmark
+currently the test and benchmark package suites can be invoked (as of cabal-install 2.4. or newer) via
+`cabal v2-test test` and `cabal v2-bench bench` respectively. They are structured as separate packages
+at this time for dependency management.
diff --git a/bench/Array/Traverse/Closure.hs b/bench/Array/Traverse/Closure.hs
new file mode 100644
index 00000000..4a7e64e7
--- /dev/null
+++ b/bench/Array/Traverse/Closure.hs
@@ -0,0 +1,49 @@
+{-# LANGUAGE BangPatterns #-}
+{-# LANGUAGE UnboxedTuples #-}
+{-# LANGUAGE RankNTypes #-}
+{-# LANGUAGE MagicHash #-}
+
+module Array.Traverse.Closure
+  ( traversePoly
+  ) where
+
+import Control.Applicative
+import Control.Monad.ST
+import Data.Primitive.Array
+import GHC.Exts (Int(..),MutableArray#)
+
+{-# INLINE traversePoly #-}
+traversePoly
+  :: Applicative f
+  => (a -> f b)
+  -> Array a
+  -> f (Array b)
+traversePoly f = \ !ary ->
+  let
+    !len = sizeofArray ary
+    go !i
+      | i == len = pure $ STA $ \mary -> unsafeFreezeArray (MutableArray mary)
+      | (# x #) <- indexArray## ary i
+      = liftA2 (\b (STA m) -> STA $ \mary ->
+                  writeArray (MutableArray mary) i b >> m mary)
+               (f x) (go (i + 1))
+  in if len == 0
+     then pure mempty
+     else runSTA len <$> go 0
+
+badTraverseValue :: a
+badTraverseValue = die "traversePoly" "bad indexing"
+{-# NOINLINE badTraverseValue #-}
+
+die :: String -> String -> a
+die fun problem = error $ "Array.Traverse.Closure" ++ fun ++ ": " ++ problem
+
+newtype STA a = STA {_runSTA :: forall s. MutableArray# s a -> ST s (Array a)}
+
+runSTA :: Int -> STA a -> Array a
+runSTA !sz = \ (STA m) -> runST $ newArray_ sz >>= \ ar -> m (marray# ar)
+{-# INLINE runSTA #-}
+
+newArray_ :: Int -> ST s (MutableArray s a)
+newArray_ !n = newArray n badTraverseValue
+
diff --git a/bench/Array/Traverse/Compose.hs b/bench/Array/Traverse/Compose.hs
new file mode 100644
index 00000000..b730852f
--- /dev/null
+++ b/bench/Array/Traverse/Compose.hs
@@ -0,0 +1,47 @@
+module Array.Traverse.Compose
+  ( traversePoly
+  , traverseMono
+  ) where
+
+import Data.Functor.Compose
+import Data.Primitive.Array
+
+{-# INLINE traversePoly #-}
+traversePoly
+  :: Applicative f
+  => (a -> f b)
+  -> Array a
+  -> f (Array b)
+traversePoly f ary = runST $ do
+  let !sz = sizeofArray ary
+  mary <- newArray sz
+  let go !i = do
+        
+    !len = sizeofArray ary
+    go !i
+      | i == len = pure $ STA $ \mary -> unsafeFreezeArray (MutableArray mary)
+      | (# x #) <- indexArray## ary i
+      = liftA2 (\b (STA m) -> STA $ \mary ->
+                  writeArray (MutableArray mary) i b >> m mary)
+               (f x) (go (i + 1))
+  in if len == 0
+     then pure emptyArray
+     else runSTA len <$> go 0
+
+badTraverseValue :: a
+badTraverseValue = die "traversePoly" "bad indexing"
+{-# NOINLINE badTraverseValue #-}
+
+die :: String -> String -> a
+die fun problem = error $ "Array.Traverse.Closure" ++ fun ++ ": " ++ problem
+
+newtype STA a = STA {_runSTA :: forall s. MutableArray# s a -> ST s (Array a)}
+
+runSTA :: Int -> STA a -> Array a
+runSTA !sz = \ (STA m) -> runST $ newArray_ sz >>= \ ar -> m (marray# ar)
+{-# INLINE runSTA #-}
+
+newArray_ :: Int -> ST s (MutableArray s a)
+newArray_ !n = newArray n badTraverseValue
+
+
diff --git a/bench/Array/Traverse/Unsafe.hs b/bench/Array/Traverse/Unsafe.hs
new file mode 100644
index 00000000..e7615a4f
--- /dev/null
+++ b/bench/Array/Traverse/Unsafe.hs
@@ -0,0 +1,48 @@
+{-# LANGUAGE BangPatterns #-}
+
+module Array.Traverse.Unsafe
+  ( traversePoly
+  , traverseMono
+  ) where
+
+import Control.Monad.ST
+import Control.Monad.Trans.State.Strict
+import Control.Monad.Primitive
+import Data.Primitive.Array
+
+{-# INLINE traversePoly #-}
+traversePoly
+  :: PrimMonad m
+  => (a -> m b)
+  -> Array a
+  -> m (Array b)
+traversePoly f = \ !ary ->
+  let
+    !sz = sizeofArray ary
+    go !i !mary
+      | i == sz
+      = unsafeFreezeArray mary
+      | otherwise
+      = do
+          a <- indexArrayM ary i
+          b <- f a
+          writeArray mary i b
+          go (i + 1) mary
+  in do
+    mary <- newArray sz badTraverseValue
+    go 0 mary
+
+badTraverseValue :: a
+badTraverseValue = die "traversePoly" "bad indexing"
+{-# NOINLINE badTraverseValue #-}
+
+die :: String -> String -> a
+die fun problem = error $ "Array.Traverse.Unsafe" ++ fun ++ ": " ++ problem
+
+-- Included to make it easy to inspect GHC Core that results
+-- from inlining traversePoly.
+traverseMono :: 
+     (Int -> StateT Word (ST s) Int)
+  -> Array Int
+  -> StateT Word (ST s) (Array Int)
+traverseMono f x = traversePoly f x
diff --git a/bench/ByteArray/Compare.hs b/bench/ByteArray/Compare.hs
new file mode 100644
index 00000000..c5aeebba
--- /dev/null
+++ b/bench/ByteArray/Compare.hs
@@ -0,0 +1,96 @@
+{-# LANGUAGE BangPatterns #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+
+module ByteArray.Compare
+  ( benchmark
+  , argumentSmall
+  , argumentMedium
+  , argumentLarge
+  ) where
+
+import Data.Primitive
+import Data.Word
+import Control.Monad
+import Control.Monad.ST (runST)
+import GHC.Exts (fromList)
+
+-- This takes the cross product of the argument with itself
+-- and compares each pair of combined ByteArrays. In other words,
+-- it compare every ByteArray to every other ByteArray (including
+-- itself). This is does efficiently and should not allocate
+-- any memory.
+benchmark :: UnliftedArray ByteArray -> Int
+benchmark !uarr = outer 0
+  where
+  sz = sizeofUnliftedArray uarr
+  outer :: Int -> Int
+  outer !v0 =
+    let go !v !ix = if ix < sz
+          then go (inner v (indexUnliftedArray uarr ix)) (ix + 1)
+          else v
+     in go v0 0
+  inner :: Int -> ByteArray -> Int
+  inner !v0 !barr =
+    let go !v !ix = if ix < sz
+          then
+            let !y = case compare barr (indexUnliftedArray uarr ix) of
+                  LT -> (-1)
+                  EQ -> 0
+                  GT -> 1
+             in go (v + y) (ix + 1)
+          else v
+     in go v0 0
+
+-- This is an array of all byte arrays consistent of the bytes 0 and 1
+-- bewteen length 0 and 7 inclusive:
+--
+-- []
+-- [0]
+-- [1]
+-- [0,0]
+-- [0,1]
+-- ...
+-- [1,1,1,1,1,1,0]
+-- [1,1,1,1,1,1,1]
+--
+-- These are very small byte arrays. All of them are smaller than a
+-- cache line. A comparison function that uses the FFI may perform
+-- worse on such inputs than one that does not.
+argumentSmall :: UnliftedArray ByteArray
+argumentSmall = runST $ do
+  let (ys :: [[Word8]]) = foldMap (\n -> replicateM n [0,1]) (enumFromTo 0 7)
+  marr <- unsafeNewUnliftedArray (length ys)
+  let go !_ [] = return ()
+      go !ix (x : xs) = do
+        writeUnliftedArray marr ix (fromList x)
+        go (ix + 1) xs
+  go 0 ys
+  unsafeFreezeUnliftedArray marr
+
+
+-- This is an array of all byte arrays consistent of the bytes 0 and 1
+-- bewteen length 0 and 7 inclusive. However, they are all padded on the
+-- left by the same 256 bytes. Comparing any two of them will require
+-- walking and comparing the first 256 bytes.
+argumentMedium :: UnliftedArray ByteArray
+argumentMedium  = runST $ do
+  let (ys :: [[Word8]]) = foldMap (\n -> map (enumFromTo 0 255 ++) (replicateM n [0,1])) (enumFromTo 0 7)
+  marr <- unsafeNewUnliftedArray (length ys)
+  let go !_ [] = return ()
+      go !ix (x : xs) = do
+        writeUnliftedArray marr ix (fromList x)
+        go (ix + 1) xs
+  go 0 ys
+  unsafeFreezeUnliftedArray marr
+
+-- Same thing but with left padding of 1024 bytes.
+argumentLarge :: UnliftedArray ByteArray
+argumentLarge  = runST $ do
+  let (ys :: [[Word8]]) = foldMap (\n -> map (concat (replicate 4 (enumFromTo 0 255)) ++) (replicateM n [0,1])) (enumFromTo 0 7)
+  marr <- unsafeNewUnliftedArray (length ys)
+  let go !_ [] = return ()
+      go !ix (x : xs) = do
+        writeUnliftedArray marr ix (fromList x)
+        go (ix + 1) xs
+  go 0 ys
+  unsafeFreezeUnliftedArray marr
diff --git a/bench/LICENSE b/bench/LICENSE
new file mode 100644
index 00000000..fc213a6f
--- /dev/null
+++ b/bench/LICENSE
@@ -0,0 +1,30 @@
+Copyright (c) 2008-2009, Roman Leshchinskiy
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+- Redistributions of source code must retain the above copyright notice,
+this list of conditions and the following disclaimer.
+ 
+- Redistributions in binary form must reproduce the above copyright notice,
+this list of conditions and the following disclaimer in the documentation
+and/or other materials provided with the distribution.
+ 
+- Neither name of the University nor the names of its contributors may be
+used to endorse or promote products derived from this software without
+specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY COURT OF THE UNIVERSITY OF
+GLASGOW AND THE CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+UNIVERSITY COURT OF THE UNIVERSITY OF GLASGOW OR THE CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGE.
+
diff --git a/bench/PrimArray/Compare.hs b/bench/PrimArray/Compare.hs
new file mode 100644
index 00000000..562da72b
--- /dev/null
+++ b/bench/PrimArray/Compare.hs
@@ -0,0 +1,58 @@
+{-# LANGUAGE BangPatterns #-}
+{-# LANGUAGE ScopedTypeVariables #-}
+
+module PrimArray.Compare
+  ( benchmarkLt
+  , benchmarkLtDef
+  , benchmarkLte
+  , benchmarkLteDef
+  , argumentA
+  , argumentB
+  ) where
+
+import Data.Primitive
+import Data.Word
+import Control.Monad
+import Control.Monad.ST (runST)
+import GHC.Exts (fromList)
+
+benchmarkLtDef :: PrimArray Int -> PrimArray Int -> Bool
+benchmarkLtDef a b = case compare a b of
+  LT -> True
+  _ -> False
+
+benchmarkLteDef :: PrimArray Int -> PrimArray Int -> Bool
+benchmarkLteDef a b = case compare a b of
+  GT -> False
+  _ -> True
+
+benchmarkLt :: PrimArray Int -> PrimArray Int -> Bool
+benchmarkLt a b =
+  let !sz1 = sizeofPrimArray a
+      !sz2 = sizeofPrimArray b
+      !sz = min sz1 sz2
+      loop !i
+        | i < sz = if indexPrimArray a i < indexPrimArray b i
+            then True
+            else loop (i + 1)
+        | otherwise = sz1 < sz2
+   in loop 0
+
+benchmarkLte :: PrimArray Int -> PrimArray Int -> Bool
+benchmarkLte a b =
+  let !sz1 = sizeofPrimArray a
+      !sz2 = sizeofPrimArray b
+      !sz = min sz1 sz2
+      loop !i
+        | i < sz = if indexPrimArray a i <= indexPrimArray b i
+            then loop (i + 1)
+            else False
+        | otherwise = sz1 < sz2
+   in loop 0
+
+argumentA :: PrimArray Int
+argumentA = fromList (enumFromTo 0 8000 ++ [55])
+
+argumentB :: PrimArray Int
+argumentB = fromList (enumFromTo 0 8000 ++ [56])
+
diff --git a/bench/PrimArray/Traverse.hs b/bench/PrimArray/Traverse.hs
new file mode 100644
index 00000000..0e2f1d54
--- /dev/null
+++ b/bench/PrimArray/Traverse.hs
@@ -0,0 +1,23 @@
+module PrimArray.Traverse
+  ( benchmarkApplicative
+  , benchmarkPrimMonad
+  , argument
+  ) where
+
+import Control.Monad.ST (runST)
+import Control.Monad.Trans.Maybe (MaybeT(..))
+import Data.Bool (bool)
+import Data.Primitive.PrimArray
+import GHC.Exts (fromList)
+
+benchmarkApplicative :: PrimArray Int -> Maybe (PrimArray Int)
+benchmarkApplicative xs = traversePrimArray (\x -> bool Nothing (Just (x + 1)) (x > 0)) xs
+
+benchmarkPrimMonad :: PrimArray Int -> Maybe (PrimArray Int)
+benchmarkPrimMonad xs = runST $ runMaybeT $ traversePrimArrayP
+  (\x -> bool (MaybeT (return Nothing)) (MaybeT (return (Just (x + 1)))) (x > 0))
+  xs
+
+argument :: PrimArray Int
+argument = fromList (enumFromTo 1 10000)
+
diff --git a/bench/README.md b/bench/README.md
new file mode 100644
index 00000000..6b25e55e
--- /dev/null
+++ b/bench/README.md
@@ -0,0 +1,7 @@
+Benchmark Suite
+=======================
+
+The benchmark suite for `primitive` cannot be included in the same package
+as `primitive` itself. The benchmark suite depends on `gauge`, which
+transitively depends on `primitive`. To break up this dependency cycle,
+the test suite lives here in its own unpublished package.
diff --git a/bench/main.hs b/bench/main.hs
new file mode 100644
index 00000000..cce32836
--- /dev/null
+++ b/bench/main.hs
@@ -0,0 +1,77 @@
+{-# LANGUAGE BangPatterns #-}
+{-# LANGUAGE CPP #-}
+{-# LANGUAGE KindSignatures #-}
+{-# LANGUAGE MagicHash #-}
+{-# LANGUAGE UnboxedTuples #-}
+{-# OPTIONS_GHC -fno-warn-orphans #-}
+
+import Gauge
+import Control.Monad.ST
+import Data.Primitive
+import Control.DeepSeq
+import Control.Monad.Trans.State.Strict
+
+-- These are fixed implementations of certain operations. In the event
+-- that primitive changes its implementation of a function, these
+-- implementations stay the same. They are helpful for ensuring that
+-- something that is a performance win in one version of GHC doesn't
+-- become a regression later. They are also helpful for evaluating
+-- how well different implementation hold up in different scenarios.
+import qualified Array.Traverse.Unsafe
+import qualified Array.Traverse.Closure
+
+-- These are particular scenarios that are tested against the
+-- implementations actually used by primitive.
+import qualified ByteArray.Compare
+import qualified PrimArray.Compare
+import qualified PrimArray.Traverse
+
+main :: IO ()
+main = defaultMain
+  [ bgroup "Array"
+    [ bgroup "implementations"
+      [ bgroup "traverse"
+        [ bench "closure" (nf (\x -> runST (runStateT (Array.Traverse.Closure.traversePoly cheap x) 0)) numbers)
+        , bench "unsafe" (nf (\x -> runST (runStateT (Array.Traverse.Unsafe.traversePoly cheap x) 0)) numbers)
+        ]
+      ]
+    ]
+  , bgroup "ByteArray"
+    [ bgroup "compare"
+      [ bench "small" (whnf ByteArray.Compare.benchmark ByteArray.Compare.argumentSmall)
+      , bench "medium" (whnf ByteArray.Compare.benchmark ByteArray.Compare.argumentMedium)
+      , bench "large" (whnf ByteArray.Compare.benchmark ByteArray.Compare.argumentLarge)
+      ]
+    ]
+  , bgroup "PrimArray"
+    [ bgroup "traverse"
+      [ bgroup "Maybe"
+        [ bench "Applicative" (whnf PrimArray.Traverse.benchmarkApplicative PrimArray.Traverse.argument)
+        , bench "PrimMonad" (whnf PrimArray.Traverse.benchmarkPrimMonad PrimArray.Traverse.argument)
+        ]
+      ]
+    , bgroup "implementations"
+      [ bgroup "less-than"
+        [ bench "default" (whnf (PrimArray.Compare.benchmarkLtDef PrimArray.Compare.argumentA) PrimArray.Compare.argumentB)
+        , bench "override" (whnf (PrimArray.Compare.benchmarkLt PrimArray.Compare.argumentA) PrimArray.Compare.argumentB)
+        ]
+      , bgroup "less-than-equal"
+        [ bench "default" (whnf (PrimArray.Compare.benchmarkLteDef PrimArray.Compare.argumentA) PrimArray.Compare.argumentB)
+        , bench "override" (whnf (PrimArray.Compare.benchmarkLte PrimArray.Compare.argumentA) PrimArray.Compare.argumentB)
+        ]
+      ]
+    ]
+  ]
+
+cheap :: Int -> StateT Int (ST s) Int
+cheap i = modify (\x -> x + i) >> return (i * i)
+
+numbers :: Array Int
+numbers = fromList (enumFromTo 0 10000)
+
+instance NFData a => NFData (Array a) where
+  rnf ary = go 0 where
+    !sz = sizeofArray ary
+    go !ix = if ix < sz
+      then ()
+      else rnf (indexArray ary ix) `seq` go (ix + 1)
diff --git a/bench/primitive-benchmarks.cabal b/bench/primitive-benchmarks.cabal
new file mode 100644
index 00000000..6a8e44e1
--- /dev/null
+++ b/bench/primitive-benchmarks.cabal
@@ -0,0 +1,56 @@
+Name:           primitive-benchmarks
+Version:        0.1
+License:        BSD3
+License-File:   LICENSE
+
+Author:         Roman Leshchinskiy <rl@cse.unsw.edu.au>
+Maintainer:     libraries@haskell.org
+Copyright:      (c) Roman Leshchinskiy 2009-2012
+Homepage:       https://github.com/haskell/primitive
+Bug-Reports:    https://github.com/haskell/primitive/issues
+Category:       Data
+Synopsis:       primitive benchmarks
+Cabal-Version:  >= 1.10
+Build-Type:     Simple
+Description:    @primitive@ benchmarks
+
+Tested-With:
+  GHC == 7.4.2,
+  GHC == 7.6.3,
+  GHC == 7.8.4,
+  GHC == 7.10.3,
+  GHC == 8.0.2,
+  GHC == 8.2.2,
+  GHC == 8.4.4,
+  GHC == 8.6.3
+
+flag primitive-benchmarks
+  default: True
+
+benchmark bench
+  if !flag(primitive-benchmarks)
+    buildable: False
+
+  Default-Language: Haskell2010
+  hs-source-dirs: .
+  main-is: main.hs
+  type: exitcode-stdio-1.0
+  ghc-options: -O2
+  other-modules:
+    Array.Traverse.Closure
+    Array.Traverse.Unsafe
+    ByteArray.Compare
+    PrimArray.Compare
+    PrimArray.Traverse
+  build-depends:
+      base >= 4.8 && < 4.13
+    , primitive
+    , deepseq
+    , ghc-prim
+    , gauge
+    , transformers >= 0.3
+
+source-repository head
+  type:     git
+  location: https://github.com/haskell/primitive
+  subdir:   bench
diff --git a/cabal.haskell-ci b/cabal.haskell-ci
new file mode 100644
index 00000000..5f4a0eb1
--- /dev/null
+++ b/cabal.haskell-ci
@@ -0,0 +1,6 @@
+ghc-head:               True
+jobs:                   2
+no-tests-no-benchmarks: False
+unconstrained:          False
+install-dependencies:   False
+copy-fields:            all
diff --git a/cabal.project b/cabal.project
new file mode 100644
index 00000000..b91d665e
--- /dev/null
+++ b/cabal.project
@@ -0,0 +1,11 @@
+packages: .
+          ./test
+          ./bench
+package primitive
+  ghc-options: -Wall
+package primitive-tests
+  ghc-options: -Wall
+package primitive-benchmarks
+  ghc-options: -Wall
+package quickcheck-classes
+  flags: -aeson -semigroupoids -semirings
diff --git a/changelog.md b/changelog.md
index 53485f66..11d19bf4 100644
--- a/changelog.md
+++ b/changelog.md
@@ -1,3 +1,44 @@
+## Changes in version 0.?.?.?
+
+  * Define `MonadFail` instances for `Array` and `SmallArray`.
+
+  * Define `unsafeInterleave`.
+
+  * Add a `Prim` instance for `StablePtr` to replace the previous
+    (invalid) `PrimUnlifted` instance.
+
+  * Add a `PrimUnlifted` instance for `StableName`.
+
+  * Add a lot more tests for `PrimArray`.
+
+  * Rework the `PrimUnlifted` class so users don't need to use `unsafeCoerce#`
+    when writing instances for GHC >= 8.0. Specifically, add an associated
+    type family, `Unlifted`, and two methods, `toUnlifted#` and `fromUnlifted#`.
+    Move the class definition from `Data.Primitive.UnliftedArray` to
+    `Data.Primitive.Types.PrimUnlifted`.
+
+## Changes in version 0.?.?.?
+
+  * Remove the `PrimUnlifted` instance for `StablePtr`. This instance would
+    cause the GC to crash if someone actually put `StablePtr`s inside
+    an `UnliftedArray`.
+
+  * Fix the `PrimUnlifted` instances for `SmallArray` and `SmallMutableArray`
+    when compiling with GHC < 7.10. Previously these would segfault.
+
+  * Remove useless accidental laziness in `atomicModifyMutVar`, making it match
+    `atomicModifyIORef`. The semantics should be the same.
+
+## Changes in version 0.6.4.1
+
+ * Add instances for the following newtypes from `base`:
+   `Const`, `Identity`, `Down`, `Dual`, `Sum`, `Product`,
+   `First`, `Last`, `Min`, `Max`
+
+ * Add `base-orphans` dependency to test suite to accomodate
+   older versions of GHC not having instances of `Show` and `Eq`
+   for some of the above newtypes.
+
 ## Changes in version 0.6.4.0
 
  * Introduce `Data.Primitive.PrimArray`, which offers types and function
@@ -37,7 +78,7 @@
 
  * Fix the implementation of `mconcat` in the `Monoid` instance for
    `SmallArray`.
- 
+
  * Implement `Data.Primitive.Ptr`, implementations of `Ptr` functions
    that require a `Prim` constraint instead of a `Storable` constraint.
 
@@ -59,6 +100,11 @@
  * Add `defaultSetByteArray#` and `defaultSetOffAddr#` to
    `Data.Primitive.Types`.
 
+ * Add `Data.Primitive.MVar`, a replacement for `Control.Concurrent.MVar`
+   that can run in any `PrimMonad` instead of just `IO`. It is not a full
+   replacement. Notably, it's missing masking functions and support for
+   adding finalizers.
+
 ## Changes in version 0.6.3.0
 
  * Add `PrimMonad` instances for `ContT`, `AccumT`, and `SelectT` from
diff --git a/primitive.cabal b/primitive.cabal
index e370f6d0..47de15a6 100644
--- a/primitive.cabal
+++ b/primitive.cabal
@@ -1,74 +1,77 @@
-Name:           primitive
-Version:        0.6.4.0
-x-revision: 1
-License:        BSD3
-License-File:   LICENSE
-
-Author:         Roman Leshchinskiy <rl@cse.unsw.edu.au>
-Maintainer:     libraries@haskell.org
-Copyright:      (c) Roman Leshchinskiy 2009-2012
-Homepage:       https://github.com/haskell/primitive
-Bug-Reports:    https://github.com/haskell/primitive/issues
-Category:       Data
-Synopsis:       Primitive memory-related operations
-Cabal-Version:  >= 1.10
-Build-Type:     Simple
-Description:    This package provides various primitive memory-related operations.
-
-Extra-Source-Files: changelog.md
-                    test/*.hs
-                    test/LICENSE
-                    test/primitive-tests.cabal
-
-Tested-With:
-  GHC == 7.4.2,
-  GHC == 7.6.3,
-  GHC == 7.8.4,
-  GHC == 7.10.3,
-  GHC == 8.0.2,
-  GHC == 8.2.2,
-  GHC == 8.4.2
-
-Library
-  Default-Language: Haskell2010
-  Other-Extensions:
-        BangPatterns, CPP, DeriveDataTypeable,
-        MagicHash, TypeFamilies, UnboxedTuples, UnliftedFFITypes
-
-  Exposed-Modules:
-        Control.Monad.Primitive
-        Data.Primitive
-        Data.Primitive.MachDeps
-        Data.Primitive.Types
-        Data.Primitive.Array
-        Data.Primitive.ByteArray
-        Data.Primitive.PrimArray
-        Data.Primitive.SmallArray
-        Data.Primitive.UnliftedArray
-        Data.Primitive.Addr
-        Data.Primitive.Ptr
-        Data.Primitive.MutVar
-        Data.Primitive.MVar
-
-  Other-Modules:
-        Data.Primitive.Internal.Compat
-        Data.Primitive.Internal.Operations
-
-  Build-Depends: base >= 4.5 && < 4.13
-               , ghc-prim >= 0.2 && < 0.6
-               , transformers >= 0.2 && < 0.6
-
-  Ghc-Options: -O2
-
-  Include-Dirs: cbits
-  Install-Includes: primitive-memops.h
-  includes: primitive-memops.h
-  c-sources: cbits/primitive-memops.c
-  if !os(solaris)
-      cc-options: -ftree-vectorize
-  if arch(i386) || arch(x86_64)
-      cc-options: -msse2
-
-source-repository head
-  type:     git
-  location: https://github.com/haskell/primitive
+Name:           primitive
+Version:        0.6.4.0
+License:        BSD3
+License-File:   LICENSE
+
+Author:         Roman Leshchinskiy <rl@cse.unsw.edu.au>
+Maintainer:     libraries@haskell.org
+Copyright:      (c) Roman Leshchinskiy 2009-2012
+Homepage:       https://github.com/haskell/primitive
+Bug-Reports:    https://github.com/haskell/primitive/issues
+Category:       Data
+Synopsis:       Primitive memory-related operations
+Cabal-Version:  >= 1.10
+Build-Type:     Simple
+Description:    This package provides various primitive memory-related operations.
+
+Extra-Source-Files: changelog.md
+                    test/*.hs
+                    test/LICENSE
+                    test/primitive-tests.cabal
+
+Tested-With:
+  GHC == 7.4.2,
+  GHC == 7.6.3,
+  GHC == 7.8.4,
+  GHC == 7.10.3,
+  GHC == 8.0.2,
+  GHC == 8.2.2,
+  GHC == 8.4.4,
+  GHC == 8.6.3
+
+Library
+  Default-Language: Haskell2010
+  Other-Extensions:
+        BangPatterns, CPP, DeriveDataTypeable,
+        MagicHash, TypeFamilies, UnboxedTuples, UnliftedFFITypes
+
+  Exposed-Modules:
+        Control.Monad.Primitive
+        Data.Primitive
+        Data.Primitive.MachDeps
+        Data.Primitive.Types
+        Data.Primitive.Types.PrimUnlifted
+        Data.Primitive.Array
+        Data.Primitive.ByteArray
+        Data.Primitive.PrimArray
+        Data.Primitive.SmallArray
+        Data.Primitive.UnliftedArray
+        Data.Primitive.Addr
+        Data.Primitive.Ptr
+        Data.Primitive.MutVar
+        Data.Primitive.MVar
+
+  Other-Modules:
+        Data.Primitive.Internal.Compat
+        Data.Primitive.Internal.Operations
+
+  Build-Depends: base >= 4.5 && < 4.14
+               , ghc-prim >= 0.2 && < 0.7
+               , transformers >= 0.2 && < 0.6
+  if !impl(ghc >= 8.0)
+    Build-Depends: fail == 4.9.*
+
+  Ghc-Options: -O2
+
+  Include-Dirs: cbits
+  Install-Includes: primitive-memops.h
+  includes: primitive-memops.h
+  c-sources: cbits/primitive-memops.c
+  if !os(solaris)
+      cc-options: -ftree-vectorize
+  if arch(i386) || arch(x86_64)
+      cc-options: -msse2
+
+source-repository head
+  type:     git
+  location: https://github.com/haskell/primitive
diff --git a/test/README.md b/test/README.md
new file mode 100644
index 00000000..059cfca4
--- /dev/null
+++ b/test/README.md
@@ -0,0 +1,25 @@
+Test Suite
+=======================
+
+The test suite for `primitive` cannot be included in the same package
+as `primitive` itself. The test suite depends on `QuickCheck`, which
+transitively depends on `primitive`. To break up this dependency cycle,
+the test suite lives here in its own unpublished package.
+
+To accelerates builds of the test suite, it is recommended to use
+`cabal new-build`, which will use the pass the flags specified in
+the `cabal.project` file to build `quickcheck-classes`. From the
+root directory of `primitive`, run the following command to build
+the test suite:
+
+    cabal new-build test --enable-tests
+
+This test suite is tested by travis. Although `primitive` supports
+versions of transformers all the way back to `transformers-0.2.0.0`,
+the test suite cannot be build with versions of transformers older than
+`transformers-0.3.0.0`.  As far as test coverage goes, this should not
+be a problem since there is no CPP that treats these two versions of
+transformers differently.  Travis tests `transformers-0.3.0.0` with
+its GHC 7.8.4 build, which provides high confidence that `primitive`
+works with every version of transformers that it claims to.
+
diff --git a/test/main.hs b/test/main.hs
index abec96df..2c56da9d 100644
--- a/test/main.hs
+++ b/test/main.hs
@@ -5,28 +5,52 @@
 {-# LANGUAGE MagicHash #-}
 {-# LANGUAGE UnboxedTuples #-}
 {-# LANGUAGE ScopedTypeVariables #-}
+{-# LANGUAGE StandaloneDeriving #-}
+
+{-# OPTIONS_GHC -fno-warn-orphans #-}
+
+#if __GLASGOW_HASKELL__ >= 805
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE DerivingStrategies #-}
+{-# LANGUAGE DerivingVia #-}
+{-# LANGUAGE TypeInType #-}
+#endif
 
-import Control.Applicative
 import Control.Monad
-import Control.Monad.Fix (fix)
-import Control.Monad.Primitive
 import Control.Monad.ST
-import Data.Monoid
 import Data.Primitive
-import Data.Primitive.Array
-import Data.Primitive.ByteArray
-import Data.Primitive.Types
-import Data.Primitive.SmallArray
-import Data.Primitive.PrimArray
 import Data.Word
 import Data.Proxy (Proxy(..))
 import GHC.Int
 import GHC.IO
 import GHC.Prim
 import Data.Function (on)
+import Control.Applicative (Const(..))
+import Foreign.StablePtr (newStablePtr,deRefStablePtr,freeStablePtr)
+import System.Mem.StableName (makeStableName)
+#if !(MIN_VERSION_base(4,8,0))
+import Data.Monoid (Monoid(..))
+#endif
+#if MIN_VERSION_base(4,8,0)
+import Data.Functor.Identity (Identity(..))
+import qualified Data.Monoid as Monoid
+#endif
+#if MIN_VERSION_base(4,6,0)
+import Data.Ord (Down(..))
+#else
+import GHC.Exts (Down(..))
+#endif
 #if MIN_VERSION_base(4,9,0)
 import Data.Semigroup (stimes)
+import qualified Data.Semigroup as Semigroup
+#endif
+#if !(MIN_VERSION_base(4,11,0))
+import Data.Monoid ((<>))
 #endif
+#if __GLASGOW_HASKELL__ >= 805
+import Foreign.Storable (Storable)
+#endif
+import Data.Orphans ()
 
 import Test.Tasty (defaultMain,testGroup,TestTree)
 import Test.QuickCheck (Arbitrary,Arbitrary1,Gen,(===),CoArbitrary,Function)
@@ -89,6 +113,7 @@ main = do
       , lawsToTest (QCC.showReadLaws (Proxy :: Proxy (Array Int)))
 #if MIN_VERSION_base(4,7,0)
       , lawsToTest (QCC.isListLaws (Proxy :: Proxy ByteArray))
+      , TQC.testProperty "foldrByteArray" (QCCL.foldrProp word8 foldrByteArray)
 #endif
       ]
     , testGroup "PrimArray"
@@ -138,11 +163,74 @@ main = do
     , testGroup "DefaultSetMethod"
       [ lawsToTest (QCC.primLaws (Proxy :: Proxy DefaultSetMethod))
       ]
-    -- , testGroup "PrimStorable"
-    --   [ lawsToTest (QCC.storableLaws (Proxy :: Proxy Derived))
-    --   ]
+#if __GLASGOW_HASKELL__ >= 805
+    , testGroup "PrimStorable"
+      [ lawsToTest (QCC.storableLaws (Proxy :: Proxy Derived))
+      ]
+#endif
+    , testGroup "Prim"
+      [ renameLawsToTest "Word" (QCC.primLaws (Proxy :: Proxy Word))
+      , renameLawsToTest "Word8" (QCC.primLaws (Proxy :: Proxy Word8))
+      , renameLawsToTest "Word16" (QCC.primLaws (Proxy :: Proxy Word16))
+      , renameLawsToTest "Word32" (QCC.primLaws (Proxy :: Proxy Word32))
+      , renameLawsToTest "Word64" (QCC.primLaws (Proxy :: Proxy Word64))
+      , renameLawsToTest "Int" (QCC.primLaws (Proxy :: Proxy Int))
+      , renameLawsToTest "Int8" (QCC.primLaws (Proxy :: Proxy Int8))
+      , renameLawsToTest "Int16" (QCC.primLaws (Proxy :: Proxy Int16))
+      , renameLawsToTest "Int32" (QCC.primLaws (Proxy :: Proxy Int32))
+      , renameLawsToTest "Int64" (QCC.primLaws (Proxy :: Proxy Int64))
+      , renameLawsToTest "Const" (QCC.primLaws (Proxy :: Proxy (Const Int16 Int16)))
+      , renameLawsToTest "Down" (QCC.primLaws (Proxy :: Proxy (Down Int16)))
+#if MIN_VERSION_base(4,8,0)
+      , renameLawsToTest "Identity" (QCC.primLaws (Proxy :: Proxy (Identity Int16)))
+      , renameLawsToTest "Dual" (QCC.primLaws (Proxy :: Proxy (Monoid.Dual Int16)))
+      , renameLawsToTest "Sum" (QCC.primLaws (Proxy :: Proxy (Monoid.Sum Int16)))
+      , renameLawsToTest "Product" (QCC.primLaws (Proxy :: Proxy (Monoid.Product Int16)))
+#endif
+#if MIN_VERSION_base(4,9,0)
+      , renameLawsToTest "First" (QCC.primLaws (Proxy :: Proxy (Semigroup.First Int16)))
+      , renameLawsToTest "Last" (QCC.primLaws (Proxy :: Proxy (Semigroup.Last Int16)))
+      , renameLawsToTest "Min" (QCC.primLaws (Proxy :: Proxy (Semigroup.Min Int16)))
+      , renameLawsToTest "Max" (QCC.primLaws (Proxy :: Proxy (Semigroup.Max Int16)))
+#endif
+        -- For StablePtr, it is not possible to use the property
+        -- tests from quickcheck-classes. Since StablePtr values can only
+        -- be created in IO and must be explicitly deallocated, we use a
+        -- custom property test that is more restricted in what it does.
+      , testGroup "StablePtr"
+        [ TQC.testProperty "element" stablePtrPrimProp
+        , TQC.testProperty "block" stablePtrPrimBlockProp
+        ]
+      ]
+    , testGroup "PrimUnlifted"
+      -- Currently, quickcheck-classes does not provide a way to test
+      -- PrimUnlifted instances. For now, we work around this by using the
+      -- property tests for the Eq instance of UnliftedArray applied
+      -- to various types. We're mostly just trying to ensure that
+      -- the instances do not cause crashes.
+      [ renameLawsToTest "Array" (QCC.eqLaws (Proxy :: Proxy (UnliftedArray (Array Integer))))
+      , renameLawsToTest "SmallArray" (QCC.eqLaws (Proxy :: Proxy (UnliftedArray (SmallArray Integer))))
+      , renameLawsToTest "ByteArray" (QCC.eqLaws (Proxy :: Proxy (UnliftedArray ByteArray)))
+      , testGroup "StableName"
+        [ TQC.testProperty "element" stableNameUnliftedPrimProp
+        , TQC.testProperty "block" stableNameUnliftedPrimBlockProp
+        ]
+      ]
     ]
 
+deriving instance Arbitrary a => Arbitrary (Down a)
+-- Const, Dual, Sum, Product: all have Arbitrary instances defined
+-- in QuickCheck itself
+#if MIN_VERSION_base(4,9,0)
+deriving instance Arbitrary a => Arbitrary (Semigroup.First a)
+deriving instance Arbitrary a => Arbitrary (Semigroup.Last a)
+deriving instance Arbitrary a => Arbitrary (Semigroup.Min a)
+deriving instance Arbitrary a => Arbitrary (Semigroup.Max a)
+#endif
+
+word8 :: Proxy Word8
+word8 = Proxy
+
 int16 :: Proxy Int16
 int16 = Proxy
 
@@ -197,6 +285,45 @@ byteArrayGrowProp = QC.property $ \(QC.NonNegative (n :: Int)) (QC.NonNegative (
         unsafeFreezeByteArray mzs1
    in expected === actual
 
+-- Tests that writing stable ptrs to a PrimArray, reading them back
+-- out, and then dereferencing them gives correct results.
+stablePtrPrimProp :: QC.Property
+stablePtrPrimProp = QC.property $ \(xs :: [Integer]) -> unsafePerformIO $ do
+  ptrs <- mapM newStablePtr xs
+  let ptrs' = primArrayToList (primArrayFromList ptrs)
+  ys <- mapM deRefStablePtr ptrs'
+  mapM_ freeStablePtr ptrs'
+  return (xs === ys)
+
+stablePtrPrimBlockProp :: QC.Property
+stablePtrPrimBlockProp = QC.property $ \(x :: Word) (QC.NonNegative (len :: Int)) -> unsafePerformIO $ do
+  ptr <- newStablePtr x
+  let ptrs' = replicatePrimArray len ptr
+  let go ix = if ix < len
+        then do
+          n <- deRefStablePtr (indexPrimArray ptrs' ix)
+          ns <- go (ix + 1)
+          return (n : ns)
+        else return []
+  ys <- go 0
+  freeStablePtr ptr
+  return (L.replicate len x === ys)
+
+-- Tests that writing stable names to an UnliftedArray and reading
+-- them back out gives correct results.
+stableNameUnliftedPrimProp :: QC.Property
+stableNameUnliftedPrimProp = QC.property $ \(xs :: [Integer]) -> unsafePerformIO $ do
+  names <- mapM makeStableName xs
+  let names' = unliftedArrayToList (unliftedArrayFromList names)
+  return (names == names')
+
+stableNameUnliftedPrimBlockProp :: QC.Property
+stableNameUnliftedPrimBlockProp = QC.property $ \(x :: Word) (QC.NonNegative (len :: Int)) -> unsafePerformIO $ do
+  name <- makeStableName x
+  mutArr <- newUnliftedArray len name
+  ptrs' <- unsafeFreezeUnliftedArray mutArr
+  return (L.replicate len name == unliftedArrayToList ptrs')
+
 -- Provide the non-negative integers up to the bound. For example:
 --
 -- >>> intsLessThan 5
@@ -205,7 +332,7 @@ intsLessThan :: Int -> [Int]
 intsLessThan i = if i < 1
   then []
   else (i - 1) : intsLessThan (i - 1)
-  
+
 byteArrayCompareProp :: QC.Property
 byteArrayCompareProp = QC.property $ \(xs :: [Word8]) (ys :: [Word8]) ->
   compareLengthFirst xs ys === compare (byteArrayFromList xs) (byteArrayFromList ys)
@@ -223,6 +350,9 @@ data Proxy1 (f :: * -> *) = Proxy1
 lawsToTest :: QCC.Laws -> TestTree
 lawsToTest (QCC.Laws name pairs) = testGroup name (map (uncurry TQC.testProperty) pairs)
 
+renameLawsToTest :: String -> QCC.Laws -> TestTree
+renameLawsToTest name (QCC.Laws _ pairs) = testGroup name (map (uncurry TQC.testProperty) pairs)
+
 testArray :: IO ()
 testArray = do
     arr <- newArray 1 'A'
@@ -265,7 +395,7 @@ testByteArray = do
 mkByteArray :: Prim a => [a] -> ByteArray
 mkByteArray xs = runST $ do
     marr <- newByteArray (length xs * sizeOf (head xs))
-    sequence $ zipWith (writeByteArray marr) [0..] xs
+    sequence_ $ zipWith (writeByteArray marr) [0..] xs
     unsafeFreezeByteArray marr
 
 instance Arbitrary1 Array where
@@ -331,12 +461,9 @@ instance Prim DefaultSetMethod where
   writeOffAddr# addr off (DefaultSetMethod n) s0 = writeOffAddr# addr off n s0
   setOffAddr# = defaultSetOffAddr#
 
--- TODO: Uncomment this out when GHC 8.6 is release. Also, uncomment
--- the corresponding PrimStorable test group above.
---
--- newtype Derived = Derived Int16
---   deriving newtype (Prim)
---   deriving Storable via (PrimStorable Derived)
-
-
-
+#if __GLASGOW_HASKELL__ >= 805
+newtype Derived = Derived Int16
+  deriving stock (Eq, Show)
+  deriving newtype (Arbitrary, Prim)
+  deriving Storable via (PrimStorable Derived)
+#endif
diff --git a/test/primitive-tests.cabal b/test/primitive-tests.cabal
index 957fe5ee..ca5a6df9 100644
--- a/test/primitive-tests.cabal
+++ b/test/primitive-tests.cabal
@@ -21,14 +21,16 @@ Tested-With:
   GHC == 7.10.3,
   GHC == 8.0.2,
   GHC == 8.2.2,
-  GHC == 8.4.2
+  GHC == 8.4.4,
+  GHC == 8.6.3
 
 test-suite test
   Default-Language: Haskell2010
   hs-source-dirs: .
   main-is: main.hs
   type: exitcode-stdio-1.0
-  build-depends: base >= 4.5 && < 4.12
+  build-depends: base >= 4.5 && < 4.13
+               , base-orphans
                , ghc-prim
                , primitive
                , QuickCheck
